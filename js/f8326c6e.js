window.localStorage.setItem("_posts",JSON.stringify({"41f196ed":{name:"%相对于谁",stat:{size:1382,mtime:"2021-01-24T11:31:30.534Z",birthtime:"2021-01-30T10:34:48.278Z"},content:{meta:{title:"%相对于谁",time:"2021-01-23",tags:["CSS"]},html:'<p>在CSS中，%是一个很常见的单位，但它在不同CSS属性中相对于的对象不尽相同，以下是各个属性中%相对于谁的梳理。</p>\n<h3 id="position-absolute中的"><code>position: absolute</code>中的%</h3>\n<p>对于设置绝对定位的元素，参照物为这个元素的祖先元素中第一个存在定位属性的元素，而%正是相对于参照物的，left/right相对于参照物的width，top/bottom相对于参照物的height。</p>\n<h3 id="position-relative中的"><code>position: relative</code>中的%</h3>\n<p>对于设置相对定位的元素，%的数值是相对于自身的，left/right相对于自身的width，top/bottom相对于自身的height。</p>\n<h3 id="position-fixed中的"><code>position: fixed</code>中的%</h3>\n<p>对于设置固定定位的元素，%的数值是相对于视口的，left/right相对于视口的width，top/bottom相对于视口的height。</p>\n<h3 id="margin和padding中的"><code>margin</code>和<code>padding</code>中的%</h3>\n<p>无论left/right还是top/bottom，都相对于父元素的宽度。</p>\n<h3 id="border-radius中的"><code>border-radius</code>中的%</h3>\n<p>相对于自身的宽高</p>\n<h3 id="background-size中的"><code>background-size</code>中的%</h3>\n<p>相对于自身的宽高</p>\n<h3 id="transform-translate中的"><code>transform: translate</code>中的%</h3>\n<p>相对于自身宽高</p>\n<h3 id="text-indent中的"><code>text-indent</code>中的%</h3>\n<p>相对于父元素的width</p>\n<h3 id="font-size中的"><code>font-size</code>中的%</h3>\n<p>相对于父元素的字体大小来计算</p>\n<h3 id="line-height中的"><code>line-height</code>中的%</h3>\n<p>相对于该元素的font-size数值计算</p>\n'}},"1fc87f82":{name:"6种实现继承的模式",stat:{size:7140,mtime:"2020-12-13T13:13:33.024Z",birthtime:"2020-12-13T10:25:56.654Z"},content:{meta:{title:"6种实现继承的模式",time:"2018-02-08",tags:["JavaScript"]},html:'<h1 id="原型链">原型链</h1>\n<p>原型链是让一个对象实例A成为另一个对象B的原型，这样B就继承于A了</p>\n<pre><code class="language-javascript">function Super(name){\n    this.name = name;\n    this.superProperty = &quot;superProperty&quot;;\n}\nSuper.prototype.sayName = function () {\n    console.log(this.name);\n};\n\nfunction Sub(name){\n    this.name = name;\n}\n// 继承Super\nSub.prototype = new Super(&quot;super&quot;);\nSub.prototype.saySuperProperty = function(){\n    console.log(this.superProperty);\n};\n\nvar sub = new Sub(&quot;sub&quot;);\nconsole.log(sub.name);  //sub\nsub.sayName();  //sub\nconsole.log(sub.superProperty);  //superProperty\nsub.saySuperProperty();  //superProperty\nconsole.log(sub instanceof Sub);  //true\nconsole.log(sub instanceof Super);  //true\nconsole.log(Sub.prototype.constructor === Super);  //true\nconsole.log(sub.constructor === Super);  //true\n\nvar sup = new Super(&quot;super&quot;);\nconsole.log(sup.name);  //super\nsup.sayName();  //super\nconsole.log(sup.superProperty);  //superProperty</code></pre>\n<p>对于上面这个例子，sub就继承于Super的实例，可以看到，我们将Sub的原型指向了一个Super的实例，这样Super实例中有的，Sub实例中都有，而且在Sub实例中定义新的属性也不会影响到Super的原型和实例\n要注意的是Sub的原型被赋值为Super的实例后不能用字面量的方式重写原型对象，因为这会让继承失效，另外，如果在Sub的实例中改变了继承而来的引用类型属性值，那么在另一个Sub实例中这个属性值也会随着改变，这也正是原型链方式的不足之处</p>\n<h1 id="借用构造函数">借用构造函数</h1>\n<p>借用构造函数的原理是在子类型构造函数的内部调用超类型构造函数</p>\n<p>示例：</p>\n<pre><code class="language-javascript">function Super(name){\n    this.name = name;\n    this.arr = [1, 2, 3];\n}\n\nfunction Sub(name){\n    Super.apply(this, arguments);\n}\n\nvar sub1 = new Sub(&quot;sub1&quot;);\nsub1.arr.push(4);\nconsole.log(sub1.arr.toString());  //1,2,3,4\nconsole.log(sub1 instanceof Sub);  //true\nconsole.log(sub1 instanceof Super);  //false\n\nvar sub2 = new Sub(&quot;sub2&quot;);\nconsole.log(sub2.arr.toString());  //1,2,3</code></pre>\n<p>在上面这个例子中我们可以看到在sub1中修改的引用类型变量arr，在sub2中并没有随之被修改，完美地解决了原型链方式继承的不足，但也有个问题（那也是构造函数模式的问题）：方法都是在构造函数中定义的，不同实例的方法即使内容、命名都一样但在内存中也是不一样的，并且因为子类仅仅是通过改变上下文调用父类构造函数，所以子类与父类的原型和实例并没有什么联系，在Super原型中定义的属性在子类中也无法访问，使用instanceof操作符也无法判断出Sub的实例是Super类型，为了解决这些不足，就有了组合继承的出现</p>\n<h1 id="组合继承">组合继承</h1>\n<p>组合继承是原型链与借用构造函数的组合，用原型链实现共享属性的继承，借用构造函数实现实例属性的继承，这是最常用的继承模式</p>\n<p>示例：</p>\n<pre><code class="language-javascript">function Super(name){\n    this.name = name;\n    this.arr = [1, 2, 3];\n}\nSuper.prototype.sayName = function(){\n    console.log(this.name);\n};\n\nfunction Sub(name){\n    Super.apply(this, arguments);\n}\nSub.prototype = new Super(&quot;sub1&quot;);\nSub.prototype.constructor = Sub;\n\nvar sub1 = new Sub(&quot;sub1&quot;);\nsub1.sayName();  //sub1\nconsole.log(sub1 instanceof Sub);  //true\nconsole.log(sub1 instanceof Super);  //true</code></pre>\n<h1 id="原型式继承">原型式继承</h1>\n<p>原型式继承的原理是借助原型，基于已有对象来创建新对象</p>\n<p>ES5中特别有个Object.create()方法规范化原型式继承，这个方法接受一个必须参数、一个可选参数，第一个是用作新对象原型的对象，第二个是为新对象定义额外属性的描述符对象</p>\n<pre><code class="language-javascript">var person = {\n    name: &quot;Nicholas&quot;,\n    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]\n};\n\nvar anotherPerson = Object.create(person, {\n    name: {\n        value: &quot;Greg&quot;\n    }\n});\nanotherPerson.friends.push(&quot;Rob&quot;);\n\nvar yetAnotherPerson = Object.create(person, {\n    name: {\n        value: &quot;Linda&quot;\n    }\n});\nyetAnotherPerson.friends.push(&quot;Barbie&quot;);\n\nalert(person.friends);  //&quot;Shelby,Court,Van,Rob,Barbie&quot;</code></pre>\n<p>要注意的是，person中的引用类型属性在某个新对象中的改变，在另一个新对象和person中也可以体现出来</p>\n<h1 id="寄生式继承">寄生式继承</h1>\n<p>寄生式继承使用一个函数来封装继承过程，与原型式继承有点类似，都需要以一个已有对象为基础</p>\n<p>示例：</p>\n<pre><code class="language-javascript">function object(o){\n    function F(){}  // 可以在F()中定义其他属性\n    F.prototype = o;\n    return new F();\n}\n\nfunction createAnother(original){\n    var clone = object(original);\n    clone.sayHi = function(){\n        alert(&quot;hi&quot;);\n    };\n    return clone;\n}\n\nvar person = {\n    name: &quot;Nicholas&quot;,\n    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]\n};\n\nvar anotherPerson = createAnother(person);\nanotherPerson.sayHi();  //&quot;hi&quot;</code></pre>\n<p>在上面这个例子中的object()函数其实是和原型式继承中提到的Object.create()函数在只传第一个参数时是一样的</p>\n<p>寄生式继承也有一个问题，就是没法函数复用，就像上面的例子中createAnother()里对clone对象绑定的sayHi()方法，每次调用createAnother()创建新对象时这个函数都会重新生成一个实例，无法做到函数复用</p>\n<h1 id="寄生组合式继承">寄生组合式继承</h1>\n<p>组合继承虽然是最常用的继承模式，但也并不是十全十美，组合模式的不足在于要调用两次父类型的构造函数，第一次是在创建子类型原型，第二次则是在子类型的构造函数中</p>\n<p>再来看一下组合模式：</p>\n<pre><code class="language-javascript">function Super(name){\n    this.name = name;\n    this.arr = [1, 2, 3];\n}\nSuper.prototype.sayName = function(){\n    console.log(this.name);\n};\n\nfunction Sub(name){\n    Super.apply(this, arguments);  // 第二次调用Super()\n}\nSub.prototype = new Super(&quot;sub1&quot;);  // 第一次调用Super()\nSub.prototype.constructor = Sub;\n\nvar sub1 = new Sub(&quot;sub1&quot;);\nsub1.sayName();  //sub1\nconsole.log(sub1 instanceof Sub);  //true\nconsole.log(sub1 instanceof Super);  //true</code></pre>\n<p>而寄生组合式继承只需调用一次</p>\n<pre><code class="language-javascript">function object(o){\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\n\nfunction inheritPrototype(sub, sup){\n    var prototype = object(sup.prototype);\n    prototype.constructor = sub;\n    sub.prototype = prototype;\n}\n\nfunction Super(name){\n    this.name = name;\n    this.color = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];\n}\nSuper.prototype.sayName = function(){\n    alert(this.name);\n};\n\nfunction Sub(name, age){\n    Super.call(this, name);\n    this.age = age;\n}\n\ninheritPrototype(Sub, Super);\n\nSub.prototype.sayAge = function(){\n    alert(this.age);\n}</code></pre>\n<p>inheritPrototype()是负责把sup的原型通过原型式继承转变为一个对象，并让这个对象成为sub的原型，这样就减少了一次对Super()的调用</p>\n'}},b518aab7:{name:"7种创建对象的模式",stat:{size:13726,mtime:"2020-12-13T12:31:50.253Z",birthtime:"2020-12-13T10:25:56.669Z"},content:{meta:{title:"7种创建对象的模式",time:"2018-02-07",tags:["JavaScript"]},html:"<blockquote>\n<p>以上例子摘自《JavaScript高级程序设计（第三版）》</p>\n</blockquote>\n"}},f2569d62:{name:"className的操作",stat:{size:2318,mtime:"2020-12-13T12:35:09.039Z",birthtime:"2020-12-13T10:25:56.677Z"},content:{meta:{title:"className的操作",time:"2019-01-27",tags:["JavaScript"]},html:'<h1 id="classname">className</h1>\n<p>在元素上的className属性可以直接以字符串形式输出所有类名，类名与类名之间用一个空格连接，该属性可读可写，兼容性良好：</p>\n<pre><code class="language-javascript">element.className  // 读\nelement.className = &#39;classname&#39;  // 写</code></pre>\n<p>但className这个属性有较大局限性，读取类名的时候只能一次性读取全部类名，写操作的时候也只能一次性重写。</p>\n<h1 id="classlist">classList</h1>\n<p>classList与className不一样，是个只读属性，返回值是一个元素的类属性的实时DOMTokenList集合，该集合类似数组，可以使用数组下标或者element.classList.item()进行获取集合中的在某个位置上的类名，另外还有add()、remove()、toggle()、replace()、contains()方法，使得对类名的操作对于className属性更加方便、标准了</p>\n<h2 id="add">add()</h2>\n<p>给元素添加类名</p>\n<pre><code class="language-javascript">element.classList.add(&#39;classname&#39;);\nelement.classList.add(...classNameArray);  // add()可以传入多参数，但就算IE11也有兼容性问题</code></pre>\n<h2 id="remove">remove()</h2>\n<p>删除元素的指定类名</p>\n<pre><code class="language-javascript">element.classList.remove(&#39;classname&#39;);\nelement.classList.remove(...classNameArray);  // add()可以传入多参数，但就算IE11也有兼容性问题</code></pre>\n<h2 id="toggle">toggle()</h2>\n<p>当只传入一个参数时，这个参数即需要添加/删除的类名，如果类名原先不存在则添加，否则删除之</p>\n<pre><code class="language-javascript">element.classList.toggle(&#39;classname&#39;);</code></pre>\n<p>当传入两个参数时，如果第二个参数的计算结果为true，则添加指定的类值，如果计算结果为false，则删除它</p>\n<h2 id="replace">replace()</h2>\n<p>把指定的旧类名替换为新类名，第一个参数为旧类名，第二个参数为新类名</p>\n<pre><code class="language-javascript">element.classList.replace(&#39;oldClassName&#39;, &#39;newClassName&#39;);</code></pre>\n<h2 id="contains">contains()</h2>\n<p>检查元素是否存在某个类名，返回值为布尔值</p>\n<pre><code class="language-javascript">element.classList.contains(&#39;classname&#39;);</code></pre>\n<p>classList的兼容性方面，从IE10才开始被IE支持，但也仅仅支持基本功能，IE11也一样，所以如果想要兼容这些浏览器那只能使用polyfill或者手动利用正则表达式等方式扩展className的功能，封装成方法进行使用</p>\n'}},a9886f24:{name:"CRA(Create-React-App)使用CSS Modules",stat:{size:1830,mtime:"2020-12-13T13:44:05.747Z",birthtime:"2020-12-13T10:25:56.685Z"},content:{meta:{title:"CRA(Create-React-App)使用CSSModules",time:"2019-04-25",tags:["JavaScript","React.js","CSS"]},html:'<p>在vue单文件组件中，我们可以在style标签上添加scoped属性来实现把标签内定义的css规则绑定到组件上而不是直接暴露到全局中：</p>\n<pre><code class="language-vue">&lt;style lang=&quot;scss&quot; scoped&gt;\n  .span {\n    font-size: 1.2rem;\n  }\n&lt;/style&gt;</code></pre>\n<p>上面定义的css规则只会作用于style标签所在的单文件组件上</p>\n<p>但在react中并没有vue这种语法，怎么把css规则作用于局部呢？</p>\n<p><a href="https://github.com/css-modules/css-modules">CSS Modules</a>就是一个很好的选择</p>\n<p>以下方法只在<code>react-scripts@2.0.0</code>或以上的版本中有效：</p>\n<p>create-react-app自带了对CSS Modules的支持，比自己配置使用CSS Modules要来得方便很多，在create-react-app的官方文档中也有说明：<a href="https://facebook.github.io/create-react-app/docs/adding-a-css-modules-stylesheet">Adding a CSS Modules Stylesheet</a></p>\n<p>首先，我们需要为一个component新建一个[name].module.css的css文件（[name]是你自定义的名称），然后在component中引入：</p>\n<pre><code class="language-javascript">import styles from &#39;./[name].module.css&#39;;</code></pre>\n<p>例如，在/src/scencs/中有页面Setting，那么/src/scencs/中有./Setting/index.js和./Setting/index.module.css，在./Setting/index.js中这么引入：</p>\n<pre><code class="language-javascript">import styles from &#39;./index.module.css&#39;;</code></pre>\n<p>/src/scencs/Setting/index.module.css的内容：</p>\n<pre><code class="language-css">.span {\n  font-size: 1.2rem;\n}</code></pre>\n<p>然后在index.js中就可以正常使用CSS Modules了：</p>\n<pre><code class="language-html">&lt;span className={styles.span}&gt;</code></pre>\n<p>如果类名是使用<code>-</code>符号连接两个英文单词的形式，如：<code>plan-id</code>，那就可以使用方括号访问对象属性的方式：</p>\n<pre><code class="language-html">&lt;span className={styles[&#39;plan-id&#39;]}&gt;</code></pre>\n'}},"5b1661d7":{name:"Electron与React结合下引入Node模块",stat:{size:1089,mtime:"2020-12-13T13:15:12.230Z",birthtime:"2020-12-13T10:25:56.691Z"},content:{meta:{title:"Electron与React结合下引入Node模块",time:"2019-04-24",tags:["JavaScript","React.js","Electron.js","Node.js"]},html:'<h1 id="问题描述">问题描述</h1>\n<p>electron与react结合后在react js文件中引入Node.js模块报错：TypeError: fs.existsSync is not a function</p>\n<p>引入方式：</p>\n<pre><code class="language-javascript">const child_process = require(&#39;child_process&#39;);\n// 或\nimport child_process from &#39;child_process&#39;;</code></pre>\n<p>package.json中主要依赖项：</p>\n<pre><code class="language-json">{\n  &quot;react&quot;: &quot;^16.8.6&quot;,\n  &quot;react-app-rewired&quot;: &quot;^2.1.1&quot;,\n  &quot;react-dom&quot;: &quot;^16.8.6&quot;,\n  &quot;react-router-dom&quot;: &quot;^5.0.0&quot;,\n  &quot;react-scripts&quot;: &quot;2.1.8&quot;,\n  &quot;electron&quot;: &quot;^4.1.4&quot;\n}</code></pre>\n<h1 id="解决方式">解决方式</h1>\n<p>React中是无法直接使用Node.js的原生模块以及electron模块的（当然，有些模块是可以使用<code>import ... from ...</code>的方式引入的，比如uuid）</p>\n<p>这种情况可以通过使用window.require的方式引入：</p>\n<pre><code class="language-javascript">const child_process = window.require(&#39;child_process&#39;);</code></pre>\n<p>而在主进程中，就可以直接使用了</p>\n<pre><code class="language-javascript">const child_process = require(&#39;child_process&#39;);</code></pre>\n'}},e50f4f55:{name:"ES5的5个数组迭代方法和2个归并方法",stat:{size:2514,mtime:"2020-12-13T12:35:38.218Z",birthtime:"2020-12-13T10:25:56.698Z"},content:{meta:{title:"ES5的5个数组迭代方法和2个归并方法",time:"2018-02-04",tags:["JavaScript"]},html:'<h1 id="迭代方法">迭代方法</h1>\n<h2 id="every">every()</h2>\n<p>对数组中的每一项运行给定的函数，如果该函数对每一项都返回true，则返回true</p>\n<p>示例：</p>\n<pre><code class="language-javascript">var arr = [1, 2, 3, 4, 5];\n\n// 检测数组元素是否都是正数\nvar result = arr.every(function(value, index, array){\n    return value &gt; 0;\n});\n\nconsole.log(result);  //true</code></pre>\n<h2 id="filter">filter()</h2>\n<p>对数组中的每一项运行给定的函数，返回该函数会返回由返回true的项组成的数组</p>\n<p>示例：</p>\n<pre><code class="language-javascript">var arr = [1, 2, 3, 4, 5];\n\n// 提取数组中大于2的元素\nvar result = arr.filter(function(value, index, array){\n    return value &gt; 2;\n});\n\nconsole.log(result.toString());  //3,4,5</code></pre>\n<h2 id="foreach">forEach()</h2>\n<p>对数组中的每一项运行给定的函数，没有返回值</p>\n<p>示例：</p>\n<pre><code class="language-javascript">var arr = [1, 2, 3, 4, 5];\n\n// 输出数组的每一个元素\narr.forEach(function(value, index, array){\n    console.log(value);\n});</code></pre>\n<h2 id="map">map()</h2>\n<p>对数组中的每一项运行给定的函数，返回每次函数调用的结果组成的数组</p>\n<p>示例：</p>\n<pre><code class="language-javascript">var arr = [1, 2, 3, 4, 5];\n\n// 把数组中的每个元素进行平方\nvar result = arr.map(function (value, index, array){\n    return value * value;\n});\n\nconsole.log(result.toString());  //1,4,9,16,25</code></pre>\n<h2 id="some">some()</h2>\n<p>对数组中的每一项运行给定的函数，如果该函数对任一项返回true，那么返回true</p>\n<p>示例：</p>\n<pre><code class="language-javascript">var arr = [1, 2, 3, 4, 5];\n\n// 检测数组中有没有1这个元素\nvar result = arr.some(function (value, index, array){\n    return value === 1;\n});\n\nconsole.log(result);  //true</code></pre>\n<h1 id="归并方法">归并方法</h1>\n<h2 id="reduce">reduce()</h2>\n<p>从数组的第一项开始，遍历到最后一项，最终返回一个值</p>\n<p>示例：</p>\n<pre><code class="language-javascript">var arr = [1, 2, 3, 4, 5];\n\n// 求数组各元素之和\nvar result = arr.reduce(function (prev, cur, index, array){\n    // prev是前一个值，cur是当前值\n    return prev + cur;\n});\n\nconsole.log(result);  //15</code></pre>\n<h2 id="reduceright">reduceRight()</h2>\n<p>从数组的最后一项开始，遍历到第一项，最终返回一个值</p>\n<p>示例：</p>\n<pre><code class="language-javascript">var arr = [1, 2, 3, 4, 5];\n\n// 求数组各元素之和\nvar result = arr.reduceRight(function (prev, cur, index, array){\n    // prev是前一个值，cur是当前值\n    return prev + cur;\n});\n\nconsole.log(result);  //15</code></pre>\n'}},"96056cc5":{name:"git安装报错：Unable to locate package git",stat:{size:401,mtime:"2020-12-13T12:35:47.374Z",birthtime:"2020-12-13T10:25:56.705Z"},content:{meta:{title:"git安装报错：Unabletolocatepackagegit",time:"2018-03-25",tags:["Linux"]},html:'<p>我在Ubuntu 16.04上使用</p>\n<pre><code class="language-bash">sudo apt-get install git</code></pre>\n<p>安装git的时候出现了Unable to locate package git的错误</p>\n<p><img src="https://s3.ax1x.com/2020/12/13/reb1YD.png" alt="img"></p>\n<p>解决办法：\n使用</p>\n<pre><code class="language-bash">sudo apt-get update</code></pre>\n<p>update完成后再安装git就不会报错了</p>\n'}},c3c9d9ee:{name:"img标签onerror属性的使用",stat:{size:1686,mtime:"2021-03-13T08:31:54.226Z",birthtime:"2021-03-13T08:38:53.989Z"},content:{meta:{title:"img标签onerror属性的使用",time:"2021-03-11",tags:["JavaScript"]},html:'<p>在开发过程中我们可能会碰上需要动态加载图片，在没有图片的时候显示特定的默认图片这样的需求，一般情况下我们会选择给src属性带上一个默认图片路径作为备用值，比如下面这样：</p>\n<pre><code class="language-vue">&lt;img :src=&quot;imgURL || defauleImgURL&quot;&gt;</code></pre>\n<p>但如果需要根据img标签会带上特定且不唯一的自定义数据来显示不同的默认图片就会比较麻烦，虽然仍然可以用提前设置好默认路径的方法实现，但代码可能会显得杂乱一些，可读性可维护性可能都不会很好，这时我们就可以利用onerror属性来实现。</p>\n<p>onerror会在图片加载过程中发生错误时触发，需要注意的是如果img标签没有src属性，onerror是不会被触发的，比如：</p>\n<pre><code class="language-vue">&lt;img :src=&quot;imgURL&quot; onerror=&quot;console.log(&#39;onerror&#39;)&quot;&gt;\n&lt;!-- imgURL为undefined，onerror中的JavaScript逻辑不会被执行 --&gt;\n&lt;!-- 可以至少让imgURL的备用值为空字符串来使得onerror被触发 --&gt;</code></pre>\n<p>onerror中的JavaScript逻辑可以通过this.dataset来访问需要的自定义属性值：</p>\n<pre><code class="language-vue">&lt;img :src=&quot;&quot; data-options=&quot;something&quot; onerror=&quot;console.log(this.dataset.options)&quot;&gt;</code></pre>\n<p>为了实现需求，不能每个onerror都写一遍逻辑，将onerror属性的内容抽离，实现一个方法</p>\n<pre><code class="language-vue">&lt;template&gt;\n    &lt;img :src=&quot;imgURL&quot; data-options=&quot;something&quot; :onerror=&quot;handler&quot;&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n    methods: {\n        handler() {\n            return &#39;console.log(this.dataset.options)&#39;\n        }\n    }\n}\n&lt;/script&gt;</code></pre>\n'}},ba2336d9:{name:"JDBC连接MySQL时出现time zone的错误",stat:{size:1417,mtime:"2020-12-13T13:15:22.413Z",birthtime:"2020-12-13T10:25:56.712Z"},content:{meta:{title:"JDBC连接MySQL时出现timezone的错误",time:"2018-05-04",tags:["Java","MySQL"]},html:'<p>代码：</p>\n<pre><code class="language-java">public static void main(String[] args) throws Exception{\n    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n    String url = &quot;jdbc:mysql://127.0.0.1:3309/mydb&quot;;\n    Connection con = DriverManager.getConnection(url, &quot;root&quot;, &quot;root&quot;);\n\n    Statement cmd = con.createStatement();\n    String sql = &quot;select * from student&quot;;\n    ResultSet rs = cmd.executeQuery(sql);\n\n    while(rs.next()){\n        int sno = rs.getInt(1);\n        String sname = rs.getString(2);\n        String sbirth = rs.getString(3);\n        String saddress = rs.getString(4);\n        System.out.println(&quot;sno: &quot; + sno + &quot;，sname: &quot; + sname + &quot;，sbirth: &quot; + sbirth + &quot;，saddress: &quot; + saddress);\n    }\n    con.close();\n}</code></pre>\n<p>报错情况：\n<em>Exception in thread “main” java.sql.SQLException: The server time zone value ‘ÖÐ¹ú±ê×¼Ê±¼ä’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.</em></p>\n<p>解决方法：\n在连接数据库的url末尾加上”?serverTimezone=UTC”，如：</p>\n<pre><code class="language-java">String url = &quot;jdbc:mysql://127.0.0.1:3309/mydb?serverTimezone=UTC&quot;;</code></pre>\n<p>这样JDBC就能顺利连接到数据库了</p>\n'}},a8ad3fd7:{name:"JS中函数传参到底是按值传递还是引用传递",stat:{size:1665,mtime:"2020-12-13T12:36:46.112Z",birthtime:"2020-12-13T10:25:56.755Z"},content:{meta:{title:"JS中函数传参到底是按值传递还是引用传递",time:"2019-01-22",tags:["JavaScript"]},html:'<p>当传入的参数是引用类型（比如一个对象）的值时我们可以发现在函数中修改对象属性是生效的，而且在函数外也可以看到相应的变化（非引用类型（基本类型）：Number、String、Boolean、Null、Undefined、Symbol，引用类型：Object、Array、Map、Set、WeakMap、WeakSet、Date、JSON等）：</p>\n<pre><code class="language-javascript">function func(obj) {\n  obj.a = 1;\n}\n\nlet myObj = {};\nfunc(myObj);\nconsole.log(myObj.a);  // 1</code></pre>\n<p>那么，是不是就可以证明在JS中是引用传递呢？不能，因为其实在JS中非引用类型的参数也是按值传递的，这里的值是指数据的地址，在函数中对这个传进来的地址进行操作也就等于对源数据进行操作，所以才有这个引用传递的假象。实际上，我们可以对上面的代码进行改造：</p>\n<pre><code class="language-javascript">function func(obj) {\n  obj.a = 1;\n  obj = new Object();  // 或者直接把字面量{}赋值给obj\n  obj.b = 1;\n}\n\nlet myObj = {};\nfunc(myObj);\nconsole.log(myObj.a);  // 1\nconsole.log(myObj.b);  // undefined</code></pre>\n<p>可以看到，在函数中对obj进行重新赋值一个新对象，属性a依然存在，此时obj的值指向了一个新对象，所以给obj新增的属性b并没有在函数外体现出来，因为新增属性a和b是分别在不同的对象上操作的。</p>\n<p>总之，在JS中，函数传参无论是基本类型的值还是引用类型的值，都是按值传递的，不存在引用传递，只不过引用类型的“值”是地址的值而已。</p>\n'}},"8b522ce2":{name:"JS中改变与绑定函数的作用域",stat:{size:3996,mtime:"2020-12-13T12:36:37.296Z",birthtime:"2020-12-13T10:25:56.747Z"},content:{meta:{title:"JS中改变与绑定函数的作用域",time:"2018-02-05",tags:["JavaScript"]},html:'<p>每个函数都包含两个非继承得来的方法：apply()和call()，这两个方法的作用一摸一样，都是在特定的作用域中调用函数，扩充作用域，第一个参数都是运行函数的作用域，不一样的地方在于，apply()所接受的第二个参数为一个数组或者是arguments对象，而call()则要求除运行函数的作用域作为第一个参数外的其余参数都要直接逐个传入</p>\n<h1 id="apply">apply()</h1>\n<pre><code class="language-javascript">window.str = &quot;global&quot;;\n\nvar obj = {\n    str: &quot;obj&quot;,\n    getStr: function(){\n        return this.str;\n    }\n};\n\nconsole.log(obj.getStr());  //obj\nconsole.log(obj.getStr.apply(window));  //global</code></pre>\n<p>像上面这个例子这样，对象obj中已存在了一个方法返回str的值，但在obj中返回的是obj中的str，而在全局中可以不必再定义一个方法来返回全局中的同名变量str，这时就可以通过apply()并传入全局环境window来使用obj中的这个方法，此时由于this指向了window，所以返回的并不是obj中的str，而是全局中的str</p>\n<p>再来看个例子：</p>\n<pre><code class="language-javascript">var obj1 = {\n    sum1: function (propertyname, x, y){\n        this[propertyname] =  x + y;\n    }\n};\n\nvar obj2 = {};\n\nvar obj3 = {};\n\nfunction sum2 (propertyname, num1, num2){\n    return obj1.sum1.apply(obj2, arguments);\n}\nfunction sum3 (propertyname, num1, num2) {\n    return obj1.sum1.apply(obj3, [propertyname, num1, num2]);\n}\n\nobj1.sum1(&quot;obj1SumResult&quot;, 1, 1);\nsum2(&quot;obj2SumResult&quot;, 1, 2);\nsum3(&quot;obj3SumResult&quot;, 1, 3);\n\nconsole.log(obj1.obj1SumResult);  //2\nconsole.log(obj2.obj2SumResult);  //3\nconsole.log(obj3.obj3SumResult);  //4</code></pre>\n<p>在上面这个例子中，有3个对象，分别是obj1，obj2，obj3，在obj1中有一个可以把两个数相加，把结果存与本对象的一个自定义名字的变量下，而obj2和obj3是空对象。现在有两个函数，其中第一个函数sum2()在执行obj1中的sum1()时this值为obj2对象，把sum2中的num1和num2两个参数相加，并存到obj2的一个自定义属性名下；第二个函数sum3()与sum2()大体相同，只是传参方式不一样，一个是传入arguments对象，一个是传入数组，这都是apply()方法所支持的传参方式</p>\n<h1 id="call">call()</h1>\n<p>call()和apply()的作用都是一样的，没有差别，差别只在于传参方式而已，call()必须把参数逐个传进去</p>\n<p>可以对上一个例子进行改造：</p>\n<pre><code class="language-javascript">var obj1 = {\n    sum1: function (propertyname, x, y){\n        this[propertyname] =  x + y;\n    }\n};\n\nvar obj2 = {};\n\nvar obj3 = {};\n\nfunction sum2 (propertyname, num1, num2){\n    return obj1.sum1.apply(obj2, arguments);\n}\nfunction sum3 (propertyname, num1, num2) {\n    return obj1.sum1.call(obj3, propertyname, num1, num2);\n}\n\nsum2(&quot;obj2SumResult&quot;, 1, 2);\nsum3(&quot;obj3SumResult&quot;, 1, 2);\n\nconsole.log(obj2.obj2SumResult);  //3\nconsole.log(obj3.obj3SumResult);  //3</code></pre>\n<p>可以看到第15行，使用了call()，并传入了与apply()相同的参数（传参方式不同），函数执行后，和的结果是相同的</p>\n<h1 id="bind">bind()</h1>\n<p>还有一个方法是bind()，这个方法会创建一个函数实例（不会马上执行），其this值会被绑定到传给bind()方法的值</p>\n<p>示例：</p>\n<pre><code class="language-javascript">var obj1 = {\n    sum1: function (propertyname, x, y){\n        this[propertyname] =  x + y;\n    }\n};\n\nvar obj2 = {};\n\nvar sum2 =  obj1.sum1.bind(obj2);\n\nobj1.sum1(&quot;obj1SumResult&quot;, 1, 1);\nsum2(&quot;obj2SumResult&quot;, 1, 2);\n\nconsole.log(obj1.obj1SumResult);  //2\nconsole.log(obj2.obj2SumResult);  //3</code></pre>\n<p>在上面这个例子中，obj1.sum1()通过bind()方法被绑定了obj2对象，创建出了一个函数实例被赋值给sum2，这时就可以通过调用sum2()来给obj2添加一个属性，其值为2个数的和，而obj1中的sum1()不会被改变，依然可以正常执行</p>\n'}},"608403ec":{name:"JS事件冒泡",stat:{size:3780,mtime:"2020-12-13T12:36:21.133Z",birthtime:"2020-12-13T10:25:56.733Z"},content:{meta:{title:"JS事件冒泡",time:"2018-02-11",tags:["JavaScript"]},html:'<p>事件冒泡是指当在一个元素上触发了某一类型事件，那么这一类型事件就会逐级向上传播，其父元素、其父元素的父元素······body元素、html元素、document直至window对象（在IE8中只传播到document为止）</p>\n<p>示例：</p>\n<p>html:</p>\n<pre><code class="language-html">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n        .box{\n            width: 100px;\n            height: 100px;\n            background-color: #00a0ff;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n&lt;script src=&quot;bubbling.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>js:</p>\n<pre><code class="language-javascript">// bubbling.js\n(function () {\n    var box = document.getElementsByClassName(&quot;box&quot;)[0],\n        body = document.body,\n        html = document.documentElement;\n\n    box.addEventListener(&quot;click&quot;, function () {\n        console.log(&quot;box was clicked&quot;);\n    }, false);\n\n    body.addEventListener(&quot;click&quot;, function(){\n        console.log(&quot;body was clicked&quot;);\n    }, false);\n\n    html.addEventListener(&quot;click&quot;, function(){\n        console.log(&quot;html was clicked&quot;);\n    }, false);\n\n    document.addEventListener(&quot;click&quot;, function(){\n        console.log(&quot;document was clicked&quot;);\n    }, false);\n\n    window.addEventListener(&quot;click&quot;, function(){\n        console.log(&quot;window was clicked&quot;);\n    }, false);\n})();</code></pre>\n<p>我们现在分别给className为box的div元素、body元素、html元素、document、window对象绑定了onclick事件，下面是单击className为box的div元素的效果：</p>\n<p><img src="https://s3.ax1x.com/2020/12/13/reqBHx.png" alt="img"></p>\n<p>可以看到，最先被触发的是className为box的div元素，接着依次是body元素、html元素、document、window对象，这体现了完整的一次冒泡过程</p>\n<p>那className为box的div元素是不是第一个知道onclick事件发生的呢？\n事实上，根据DOM2级事件规定(<a href="https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html">Document Object Model (DOM) Level 2 Events Specification</a>)中的事件流描述(<a href="https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-flow-capture">Description of event flow</a>)，事件流包括三个阶段：捕获阶段、目标阶段、冒泡阶段\n当我们单击className为box的div元素后，document捕获到onclick事件，接着是html元素捕获到了，到className为box的div元素的父元素捕获到后，捕获阶段停止，进入目标阶段，onclick事件在className为box的div元素上发生，并在事件处理中被看成冒泡阶段的一部分，接着其父元素发生onclick事件，直至冒泡到document</p>\n<p>在DOM3级的UI事件草案(<a href="https://www.w3.org/TR/2016/WD-uievents-20160804/">UI Events</a>)中的<a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-flow">Event dispatch and DOM event flow</a>还把window对象增加进事件流的描述中</p>\n<p><img src="https://s3.ax1x.com/2020/12/13/reqsUK.png" alt="img"></p>\n<p>事件冒泡有时会捣乱了我们的预期效果，触发了不该触发的事件，这时就需要去阻止事件冒泡了，而stopPropagation()方法就是用来停止事件在DOM层次中的传播的</p>\n<p>还是上一个例子，我们对绑定到className为box的div元素上的事件处理函数进行改动，其他代码均保存原样：</p>\n<pre><code class="language-javascript">box.addEventListener(&quot;click&quot;, function (event) {\n    console.log(&quot;box was clicked&quot;);\n    event.stopPropagation();\n}, false);</code></pre>\n<p>这次，我们依然单击className为box的div元素，使其触发onclick事件，结果：</p>\n<p><img src="https://s3.ax1x.com/2020/12/13/reqy4O.png" alt="img"></p>\n<p>可以看到，事件冒泡到className为box的div元素就停止了</p>\n'}},"37f61fce":{name:"JS常见事件类型",stat:{size:11654,mtime:"2020-12-13T12:36:04.386Z",birthtime:"2020-12-13T10:25:56.720Z"},content:{meta:{title:"JS常见事件类型",time:"2018-02-12",tags:["JavaScript"]},html:'<h1 id="ui事件">UI事件</h1>\n<h2 id="load事件">load事件</h2>\n<p>load事件是在页面/图像/某些元素加载完成后触发的事件</p>\n<h3 id="页面加载完成时">页面加载完成时</h3>\n<p>当页面加载完成后会在window对象上触发load事件：</p>\n<pre><code class="language-javascript">window.addEventListener(&quot;load&quot;, function(){\n    console.log(&quot;loaded&quot;);\n}, false)</code></pre>\n<h3 id="图像加载完成时">图像加载完成时</h3>\n<p>当图片加载完成时会在img元素上触发load事件：</p>\n<pre><code class="language-javascript">var img = document.getElementsByClassName(&quot;img&quot;)[0];\nimg.addEventListener(&quot;load&quot;, function(){\n    console.log(&quot;loaded&quot;);\n}, false);</code></pre>\n<h3 id="script与link元素">script与link元素</h3>\n<p>script与link元素也可以触发load事件:</p>\n<pre><code class="language-javascript">var script = document.getElementsByTagName(&quot;script&quot;)[0];\nscript.addEventListener(&quot;load&quot;, function(){\n    console.log(&quot;loaded&quot;);\n}, false);\n\nvar link = document.getElementsByTagName(&quot;link&quot;)[0];\nlink.addEventListener(&quot;load&quot;, function(){\n    console.log(&quot;loaded&quot;);\n}, false);</code></pre>\n<h2 id="resize事件">resize事件</h2>\n<p>resize事件是当页面被调整到一个新的高度或宽度时在window对象上触发的：</p>\n<pre><code class="language-javascript">window.addEventListener(&quot;resize&quot;, function(){\n    console.log(&quot;resized&quot;);\n}, false);</code></pre>\n<h2 id="scroll事件">scroll事件</h2>\n<p>scroll事件在页面滚动后发生在window对象上：</p>\n<pre><code class="language-javascript">window.addEventListener(&quot;scroll&quot;, function(){\n    // 页面垂直滚动后输出垂直滚动的位置\n    console.log(document.documentElement.scrollTop);\n}, false);</code></pre>\n<h1 id="焦点事件">焦点事件</h1>\n<p>焦点事件是在页面内元素获得/失去焦点时触发</p>\n<h2 id="blus事件">blus事件</h2>\n<p>在元素失去焦点时触发，不会冒泡：</p>\n<p>html:</p>\n<pre><code class="language-html">&lt;div class=&quot;box&quot; tabindex=&quot;0&quot;&gt;&lt;/div&gt;\n&lt;!-- div在不添加tabindex属性时无法获得焦点 --&gt;</code></pre>\n<p>js:</p>\n<pre><code class="language-javascript">var box = document.getElementsByClassName(&quot;box&quot;)[0];\nbox.focus();\nbox.addEventListener(&quot;blur&quot;, function(){\n    console.log(&quot;lose focus&quot;);\n}, false);</code></pre>\n<h2 id="focus事件">focus事件</h2>\n<p>focus事件是在元素获得焦点时触发，不会冒泡</p>\n<p>html:</p>\n<pre><code class="language-html">&lt;div class=&quot;box&quot; tabindex=&quot;0&quot;&gt;&lt;/div&gt;\n&lt;!-- div在不添加tabindex属性时无法获得焦点 --&gt;</code></pre>\n<p>js:</p>\n<pre><code class="language-javascript">var box = document.getElementsByClassName(&quot;box&quot;)[0];\nbox.addEventListener(&quot;focus&quot;, function(){\n    console.log(&quot;on focus&quot;);\n}, false);\nbox.focus();</code></pre>\n<h2 id="focusin事件">focusin事件</h2>\n<p>focusin事件与focus事件等同，但它冒泡</p>\n<p>html:</p>\n<pre><code class="language-html">&lt;body&gt;\n    &lt;div class=&quot;box&quot; tabindex=&quot;0&quot;&gt;&lt;/div&gt;\n    &lt;!-- div在不添加tabindex属性时无法获得焦点 --&gt;\n&lt;/body&gt;</code></pre>\n<p>js:</p>\n<pre><code class="language-javascript">var box = document.getElementsByClassName(&quot;box&quot;)[0],\n    body = document.body;\nbody.addEventListener(&quot;focusin&quot;, function(){\n    console.log(&quot;on focus&quot;);\n}, false);\nbox.addEventListener(&quot;focusin&quot;, function(){\n    console.log(&quot;on focus&quot;);\n}, false);\nbox.focus();</code></pre>\n<h2 id="focusout事件">focusout事件</h2>\n<p>focusout事件与blus事件等同，但它冒泡</p>\n<p>html:</p>\n<pre><code class="language-html">&lt;body&gt;\n    &lt;div class=&quot;box&quot; tabindex=&quot;0&quot;&gt;&lt;/div&gt;\n    &lt;!-- div在不添加tabindex属性时无法获得焦点 --&gt;\n&lt;/body&gt;</code></pre>\n<p>js:</p>\n<pre><code class="language-javascript">var box = document.getElementsByClassName(&quot;box&quot;)[0],\n    body = document.body;\nbody.addEventListener(&quot;focusout&quot;, function(){\n    console.log(&quot;lose focus&quot;);\n}, false);\nbox.addEventListener(&quot;focusout&quot;, function(){\n    console.log(&quot;lose focus&quot;);\n}, false);\nbox.focus();</code></pre>\n<h1 id="鼠标事件">鼠标事件</h1>\n<h2 id="click事件">click事件</h2>\n<p>当主鼠标按钮被按下时被触发，冒泡</p>\n<pre><code class="language-javascript">var box = document.getElementsByClassName(&quot;box&quot;)[0];\nbox.addEventListener(&quot;click&quot;, function(){\n    console.log(&quot;on clock&quot;);\n}, false);</code></pre>\n<p>所有鼠标事件被触发时都有鼠标的位置信息被存储在事件对象event中，包括客户区坐标（页面区域，但不计算页面滚动距离）、页面坐标位置（计算了页面滚动的距离）、屏幕坐标位置</p>\n<p>由于IE8中不支持事件对象上的页面坐标，所以要通过客户区坐标和滚动信息计算出来</p>\n<pre><code class="language-java">var box = document.getElementsByClassName(&quot;box&quot;)[0];\nbox.addEventListener(&quot;click&quot;, function(event){\n    var pageX =  event.pageX,\n        pageY = event.pageY;\n    if(pageX === undefined){\n        pageX = event.clientX + document.documentElement.scrollLeft;\n        pageY = event.clientY + document.documentElement.scrollTop\n    }\n    console.log(&quot;鼠标相对于客户区的坐标：&quot; + event.clientX + &quot;, &quot; + event.clientY);\n    console.log(&quot;鼠标相对于页面的坐标：&quot; + pageX + &quot;,&quot; + pageY);\n    console.log(&quot;鼠标相对于屏幕的坐标：&quot; + event.screenX + &quot;, &quot; + event.screenY)\n}, false);</code></pre>\n<p>事件对象event中还存有几个键，分别是Shift、Ctrl、Alt和Meta（在Windows中是Windows键，在Mac OS中是Cmd键），他们在event中分别是shiftKey、ctrlKey、altKey和metaKey，对应的值都是布尔值，true为按下，false反之。这些键被称为修改键，当按下这些键后触发鼠标事件可以影响鼠标事件</p>\n<p>比如：当按下Ctrl键后触发click事件输出”click”：</p>\n<pre><code class="language-javascript">var box = document.getElementsByClassName(&quot;box&quot;)[0];\nbox.addEventListener(&quot;click&quot;, function(event){\n    if(event.ctrlKey){\n        console.log(&quot;click&quot;);\n    }\n}, false);</code></pre>\n<h2 id="dblclick事件">dblclick事件</h2>\n<p>当双击主鼠标按钮时被触发，冒泡</p>\n<pre><code class="language-javascript">var box = document.getElementsByClassName(&quot;box&quot;)[0];\nbox.addEventListener(&quot;dblclick&quot;, function(){\n    console.log(&quot;dblclock&quot;);\n}, false);</code></pre>\n<h2 id="mousedown事件">mousedown事件</h2>\n<p>当按下了任意鼠标按钮时被触发，冒泡</p>\n<pre><code class="language-javascript">var box = document.getElementsByClassName(&quot;box&quot;)[0];\nbox.addEventListener(&quot;mousedown&quot;, function(){\n    console.log(&quot;mousedown&quot;);\n}, false);</code></pre>\n<h2 id="mouseup事件">mouseup事件</h2>\n<p>当释放鼠标按钮时被触发，冒泡</p>\n<pre><code class="language-javascript">var box = document.getElementsByClassName(&quot;box&quot;)[0];\nbox.addEventListener(&quot;mouseup&quot;, function(){\n    console.log(&quot;mouseup&quot;);\n}, false);</code></pre>\n<p>对于mousedown和mouseup事件，事件对象event中都有一个button属性，这个属性有3个值，0表示主鼠标按钮，1表示鼠标中键，2表示次鼠标按钮</p>\n<p>示例（当主鼠标按钮触发mouseup事件时输出”mouseup”）：</p>\n<pre><code class="language-javascript">    var box = document.getElementsByClassName(&quot;box&quot;)[0];\n    box.addEventListener(&quot;mouseup&quot;, function(event){\n        if(event.button === 0){\n            console.log(&quot;mouseup&quot;);\n        }\n    }, false);</code></pre>\n<p>如果要兼容IE8，则要注意IE8中的button属性值与DOM中的button属性值不一样：\n0：表示没有按下按钮\n1：表示按下了主鼠标按钮\n2：表示按下了次鼠标按钮\n3：表示同时按下了主次鼠标按钮\n4：表示按下了鼠标中键\n5：表示同时按下了主中鼠标按钮\n6：表示同时按下了次中鼠标按钮\n7：表示同时按下了主中次鼠标按钮</p>\n<h2 id="mouseout事件">mouseout事件</h2>\n<p>当鼠标指针位于一个元素上方，被移入另一个元素（可能是其子元素，也可能是其父元素及其他外部元素）时被触发，冒泡</p>\n<pre><code class="language-javascript">var box = document.getElementsByClassName(&quot;box&quot;)[0];\nbox.addEventListener(&quot;mouseout&quot;, function(){\n    console.log(&quot;mouseout&quot;);\n}, false);</code></pre>\n<h2 id="mouseover事件">mouseover事件</h2>\n<p>当鼠标指针位于一个元素外部，被移入另一个元素内时被触发，冒泡</p>\n<pre><code class="language-javascript">var box = document.getElementsByClassName(&quot;box&quot;)[0];\nbox.addEventListener(&quot;mouseover&quot;, function(){\n    console.log(&quot;mouseover&quot;);\n}, false);</code></pre>\n<h2 id="mousemove事件">mousemove事件</h2>\n<p>当鼠标指针位于一个元素内部移动时被重复触发，冒泡</p>\n<pre><code class="language-javascript">var box = document.getElementsByClassName(&quot;box&quot;)[0];\nbox.addEventListener(&quot;mousemove&quot;, function(){\n    console.log(&quot;mousemove&quot;);\n}, false);</code></pre>\n<h2 id="mouseenter事件">mouseenter事件</h2>\n<p>当鼠标指针从元素外部移动到元素范围之内时被触发，不冒泡</p>\n<pre><code class="language-javascript">var box = document.getElementsByClassName(&quot;box&quot;)[0];\nbox.addEventListener(&quot;mouseenter&quot;, function(){\n    console.log(&quot;mouseenter&quot;);\n}, false);</code></pre>\n<h2 id="mouseleave事件">mouseleave事件</h2>\n<p>当位于元素上方的鼠标指针移出元素以外（移动到其后代元素不触发）时被触发，不冒泡</p>\n<pre><code class="language-javascript">var box = document.getElementsByClassName(&quot;box&quot;)[0];\nbox.addEventListener(&quot;mouseleave&quot;, function(){\n    console.log(&quot;mouseleave&quot;);\n}, false);</code></pre>\n<h2 id="contextmenu事件">contextmenu事件</h2>\n<p>鼠标右键调出上下文菜单的事件，冒泡，所以可以冒泡到document处再处理事件</p>\n<p>示例（自定义上下文菜单）：</p>\n<p>html:</p>\n<pre><code class="language-html">&lt;ul id=&quot;menu&quot;&gt;\n    &lt;li&gt;菜单1&lt;/li&gt;\n    &lt;li&gt;菜单2&lt;/li&gt;\n    &lt;li&gt;菜单3&lt;/li&gt;\n&lt;/ul&gt;</code></pre>\n<p>css:</p>\n<pre><code class="language-css">#menu{\n    display: none;\n    position: absolute;\n    padding: 5px 10px;\n    width: 100px;\n    list-style: none;\n    background-color: #f5f5f5;\n}</code></pre>\n<p>js:</p>\n<pre><code class="language-javascript">document.addEventListener(&quot;contextmenu&quot;, function(event){\n    event.preventDefault();  // 取消默认行为\n\n    var menu = document.getElementById(&quot;menu&quot;);\n    menu.style.left = event.clientX + &quot;px&quot;;\n    menu.style.top = event.clientY + &quot;px&quot;;\n    menu.style.display = &quot;block&quot;;\n}, false);\n\n// 取消菜单显示\ndocument.addEventListener(&quot;click&quot;, function(){\n    var menu = document.getElementById(&quot;menu&quot;);\n    menu.style.display = &quot;none&quot;;\n}, false);</code></pre>\n<h1 id="鼠标滚轮事件">鼠标滚轮事件</h1>\n<h2 id="mousewheel事件">mousewheel事件</h2>\n<p>当使用鼠标滚轮在页面滚动（无论是向上还是向下）就会触发，冒泡\n事件对象event中会存在一个wheelDelta属性，这个属性的值在向前滚动鼠标滚轮时为120的倍数，在向后滚动鼠标滚轮时为-120的倍数</p>\n<pre><code class="language-javascript">document.addEventListener(&quot;mousewheel&quot;, function(event){\n    console.log(event.wheelDelta);\n}, false);</code></pre>\n<p>但火狐浏览器并不支持这一事件，火狐浏览器支持的是DOMMouseScroll事件，与mousewheel事件类似，但有关鼠标滚轮的信息保存在了事件对象event的detail属性中，当向前滚动鼠标滚轮时其值为-3的倍数，向后滚动鼠标滚轮时其值为3的倍数</p>\n<pre><code class="language-javascript">document.addEventListener(&quot;DOMMouseScroll&quot;, function(event){\n    console.log(event.detail);\n}, false);</code></pre>\n<h1 id="键盘事件">键盘事件</h1>\n<h2 id="keydown事件">keydown事件</h2>\n<p>当按下键盘上任意键时触发，如果按住不放则重复触发</p>\n<pre><code class="language-javascript">document.addEventListener(&quot;keydown&quot;, function(event){\n    console.log(event.key);\n}, false);</code></pre>\n<p>事件对象event中的key属性存储了被按下的键名，但这个属性对旧浏览器兼容性并不是太好，而keyCode属性则新旧浏览器都可以使用，其值是键的ASII码（要注意的是分号键在不同浏览器中可能有不同的值，可能为59，也可能为186）</p>\n<p>此外，键盘事件中事件对象event里也有修改键属性</p>\n<h2 id="keyup事件">keyup事件</h2>\n<p>当按下的键被释放时触发</p>\n<pre><code class="language-javascript">document.addEventListener(&quot;keyup&quot;, function(event){\n    console.log(event.key);\n}, false);</code></pre>\n<h2 id="keypress事件">keypress事件</h2>\n<p>当按下键盘上的任意键时触发，如果按住不放则重复触发</p>\n<pre><code class="language-javascript">document.addEventListener(&quot;keypress&quot;, function(event){\n    console.log(event.key);\n}, false);</code></pre>\n<h1 id="文本事件">文本事件</h1>\n<h2 id="textinput事件">textInput事件</h2>\n<p>在可编辑区域中输入字符时触发</p>\n<p>html:</p>\n<pre><code class="language-html">&lt;form action=&quot;&quot;&gt;\n    &lt;label for=&quot;textBox&quot;&gt;input: &lt;/label&gt;\n    &lt;input type=&quot;text&quot; id=&quot;textBox&quot;&gt;\n&lt;/form&gt;</code></pre>\n<p>js:</p>\n<pre><code class="language-javascript">var textBox = document.getElementById(&quot;textBox&quot;);\ntextBox.addEventListener(&quot;textInput&quot;, function(event){\n    console.log(event.data);\n}, false);</code></pre>\n<p>事件对象event中的data属性存有输入的字符串</p>\n'}},"42240bf2":{name:"JS模拟鼠标事件",stat:{size:2581,mtime:"2020-12-13T12:36:13.060Z",birthtime:"2020-12-13T10:25:56.727Z"},content:{meta:{title:"JS模拟鼠标事件",time:"2018-02-13",tags:["JavaScript"]},html:'<p>在JS中模拟事件需要在document对象上使用createEvent()方法创建event对象，该方法只有一个参数，为字符串，但这个字符串的值非常多，都是事件的种类，比较常用的是鼠标事件</p>\n<pre><code class="language-javascript">var mouseEvent = document.createEvent(&quot;MouseEvent&quot;);</code></pre>\n<p>创建事件对象后需要使用不同事件对应的初始化方法进行初始化\n模拟鼠标事件的初始化事件对象方法是initMouseEvent()\n其参数及含义：\ntype（字符串）： 表示要触发的事件类型，例如”click”\nbubbles（布尔值）： 表示事件是否应该冒泡\ncancelable（布尔值）： 表示事件是否可以取消\nview（AbstractView）： 与事件关联的视图，几乎总要设置为document.defaultView\ndetail（整数）： 与事件有关的详细信息，通常设为0\nscreenX（整数）： 事件相对于屏幕的X坐标\nscreenY（整数）： 事件相对于屏幕的Y坐标\nclientX（整数）： 事件相对于视口的X坐标\nclientY（整数）： 事件相对于视口的Y坐标\nctrlKey（布尔值）： 是否按下了Ctrl键，默认值为false\naltKey（布尔值）： 是否按下了Alt键，默认值为false\nshiftKey（布尔值）： 是否按下了shift键，默认值为false\nmetaKey（布尔值）： 是否按下了Meta键，默认值为false\nbutton（整数）： 表示按下了哪个鼠标键，默认为0\nrelatedTarget（对象）：与事件相关的对象，只在模拟mouseover或mouseout时使用</p>\n<pre><code class="language-javascript">mouseEvent.initMouseEvent(&quot;click&quot;, true, true, document.defaultView, 0, 0, 0, 0, 0, false, false, false, false, 0, null);</code></pre>\n<p>最后还需要调用dispatchEvent()方法触发事件：</p>\n<p>完整代码：</p>\n<p>html:</p>\n<pre><code class="language-html">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre>\n<p>css:</p>\n<pre><code class="language-css">.box{\n    width: 100px;\n    height: 100px;\n    background-color: #00a0ff;\n}</code></pre>\n<p>js:</p>\n<pre><code class="language-javascript">(function () {\n    var box = document.getElementsByClassName(&quot;box&quot;)[0];\n    box.addEventListener(&quot;click&quot;, function(){\n        console.log(&quot;on click&quot;);\n    }, false);\n\n    // 创建事件对象\n    var mouseEvent = document.createEvent(&quot;MouseEvent&quot;);\n\n    // 初始化事件对象\n    mouseEvent.initMouseEvent(&quot;click&quot;, true, true, document.defaultView, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\n    // 触发事件\n    box.dispatchEvent(mouseEvent);\n})();</code></pre>\n<p>触发事件后会在控制台输出”on click”，证明click事件成功被模拟并触发</p>\n'}},ab769c85:{name:"JS正则的lastIndex属性",stat:{size:1306,mtime:"2020-12-13T12:36:29.072Z",birthtime:"2020-12-13T10:25:56.740Z"},content:{meta:{title:"JS正则的lastIndex属性",time:"2018-05-06",tags:["JavaScript"]},html:'<p>先来看看以下代码：</p>\n<pre><code class="language-javascript">var re = /.*/g;\nvar s1 = &quot;test string&quot;;\nvar s2 = &quot;teststring&quot;;\nconsole.log(re.test(s1));  // true\nconsole.log(re.test(s2));  // false</code></pre>\n<p>可以看到，第二次在正则表达式re上使用test()方法时原本该输出true却输出了false\n这是因为正则表达式的下一次匹配起始位置即lastIndex属性大于第二次要匹配的字符串的长度，这个属性只由正则表达式的exec()和test()两个方法产生，且在全局匹配模式下才有效\n所以可以取消全局匹配模式来解决这个问题：</p>\n<pre><code class="language-javascript">var re = /.*/;\nvar s1 = &quot;test string&quot;;\nvar s2 = &quot;teststring&quot;;\nconsole.log(re.test(s1));  // true\nconsole.log(re.test(s2));  // true</code></pre>\n<p>但有时候需要全局匹配模式，不能取消怎么办？\n还有办法，lastIndex属性是可读可写的，所以可以通过修改lastIndex属性的值来解决：</p>\n<pre><code class="language-javascript">var re = /.*/g;\nvar s1 = &quot;test string&quot;;\nvar s2 = &quot;teststring&quot;;\nconsole.log(re.test(s1));  // true\nre.lastIndex = 0;\nconsole.log(re.test(s2));  // true</code></pre>\n<p>另外，lastIndex属性还有其他特性：\n当匹配失败后，lastIndex属性的值会被设置成0</p>\n'}},"049cedb6":{name:"mongoose多表关联查询",stat:{size:4069,mtime:"2020-12-13T13:15:41.207Z",birthtime:"2020-12-13T10:25:56.762Z"},content:{meta:{title:"mongoose多表关联查询",time:"2019-04-14",tags:["JavaScript","MongoDB","Node.js"]},html:'<p>在mongoose中实现多表关联查询需要用到<a href="https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/#aggregation-pipeline-stages">db.collection.aggregate()</a></p>\n<p>先来看个多表关联查询的例子：</p>\n<pre><code class="language-javascript">await db.courses.aggregate([\n  {\n    $match: { id: &#39;xxx&#39; }\n  },\n  {\n    $lookup: {\n      from: &quot;teachers&quot;,\n      localField: &quot;teacherID&quot;,\n      foreignField: &quot;id&quot;,\n      as: &quot;tch&quot;\n    }\n  },\n  {\n    $project: {\n      _id: 0,\n      __v: 0,\n      tch: { \n        _id: 0,\n        __v: 0,\n      }\n    }\n  }\n])\n    .then(docs =&gt; {})\n    .catch(err =&gt; {});</code></pre>\n<p>假设有courses集合，存放课程的相关数据，其中id字段为该课程的唯一标识，每一课程有一个授课老师，在集合中用teacherID字段存放该教师的工号；有teachers集合，存放所有老师的相关数据，其中id字段为该教师的工号，是教师唯一标识。</p>\n<p>回到上面的代码，首先先看$match，这里应为一个对象，用于匹配courses集合中的字段，在这里是匹配id为”xxx”的数据。</p>\n<p>接下来是$lookup，其中from属性的值为你要关联的集合名，我们要获取教师的信息，所以是teachers集合；localField属性的值为现在所处的集合（courses）中的需要作为关联条件的字段，我们需要teacherID来匹配teachers集合中的数据，所以填teacherID；foreignField属性的值为form属性的这一个集合（courses）中的需要与localField属性的这一个字段相匹配的字段（即是说localField的值是subject集合中的字段名，而foreignField的值是teachers集合中的字段名，并且localField和foreignField这两个字段名的值要相同）；as属性的值是查询结果中存储查询到的关联数据的属性名，是由你来自定义的，在上面的例子中假如根据teacherID查询到teachers集合中的某一条数据，那么这条数据将会存在于查询结果docs的tch属性中（因为$lookupas中as属性的值就为tch）。</p>\n<p>最后是$project，这个对象用于设置哪些字段不存在于查询结果中（1为获取，0为不获取）。</p>\n<blockquote>\n<p>查询结果docs是一个数组，元素是查询到的数据。</p>\n</blockquote>\n<p>aggregate方法并不只有$match、$lookup、$project可配置，还有更多stage请看<a href="https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/#aggregation-pipeline-stages">文档</a></p>\n<p>上面的例子只是利用一个集合中的第一层子字段来关联另一个表来进行查询操作，那如果一个集合中有个字段值是数组，需要利用这个数组中元素的某一属性来进行关联另一个表呢？</p>\n<pre><code class="language-javascript">await db.courses.aggregate([\n  {\n    $match: { id: &#39;xxx&#39; }\n  },\n  {\n    $lookup: {\n      from: &quot;students&quot;,\n      localField: &quot;stus.id&quot;,\n      foreignField: &quot;id&quot;,\n      as: &quot;stus&quot;\n    }\n  }\n])\n    .then(docs =&gt; {})\n    .catch(err =&gt; {});</code></pre>\n<p>与上一个例子类似，还是courses集合，不过这次我们已知courses集合的数据中还有一个字段stus，它是一个用来存储学习该课程的学生信息对象，其中一个属性是id（学生的学号，作为学生的唯一标识），现在需要依靠这些学生的id关联students集合来获取更多关于这些学生的信息，students集合中的每一条数据中都有字段id存放学生的学号。</p>\n<p>$lookup中，from属性是要关联的集合名，所以填students；localField应填courses集合中存放学生的学号的属性名作为与关联集合的匹配条件，即stus中的每个元素的属性：id，但在这里可以用stus.id表示；foreignField填students集合中需要作为与courses集合关联的匹配字段，所以为id，as填stus，将关联查询到的结果存到属性stus中。</p>\n<p>最后的查询结果数组docs中的元素的stus属性也为一个数组，其中的元素就是关联查询到的students集合中的数据。</p>\n'}},d787476d:{name:"MySQL插入中文报错：ERROR 1366 (HY000)",stat:{size:1624,mtime:"2020-12-13T12:37:14.185Z",birthtime:"2020-12-13T10:25:56.769Z"},content:{meta:{title:"MySQL插入中文报错：ERROR1366(HY000)",time:"2018-05-03",tags:["MySQL"]},html:'<p>MySQL安装完后默认是latin1编码，当我们在表中插入中文后就会出现ERROR 1366 (HY000)的报错，写入失败，某书上有这样的解决方法：</p>\n<p>1、找到MYSQL安装目录中的一个名为my.ini的数据配置文件。\n2、找到文件中两处“default-character-set=latinl”，将latinl换成GBK。\n3、重新启动MySQL服务即可。如果在此之前创建过数据库，则可以先删除数据库，在服务重新启动后再重新创建。</p>\n<p>但这个方法并没有帮我解决到ERROR 1366 (HY000)的问题，上网找过好几篇文章后找到了如下可行方法：</p>\n<p>登录MySQL\n输入：</p>\n<pre><code class="language-bash">show variables like &#39;%char%&#39;;</code></pre>\n<p>就会显示当前的字符集设定</p>\n<p>我们需要把所有字符集的项都设定成utf-8\n如：设置character_set_database为utf-8：</p>\n<pre><code class="language-bash">set character_set_database=utf8;</code></pre>\n<p>剩下的设置项的设置方法如上，只需将character_set_database替换成要设置的项名即可</p>\n<p>设置完成后：</p>\n<p><img src="https://s3.ax1x.com/2020/12/13/rebKw6.png" alt="img"></p>\n<p>这时已经可以成功在Navicat Premium中插入中文了，但在命令行中还是会报ERROR 1366 (HY000)的错\n解决方法：</p>\n<p>输入：</p>\n<pre><code class="language-bash">set character_set_client=gbk;\nset character_set_results=gbk;</code></pre>\n<p>这时在命名行中对表插入中文也没有报错了，但是这个方法只对当前本次修改起作用，一旦把MySQL的命令行窗口关掉以后又恢复了，只能在下一次又再输入两次上面两条命令</p>\n'}},"138eb258":{name:"Number()与parseInt()",stat:{size:3275,mtime:"2020-12-13T12:37:23.133Z",birthtime:"2020-12-13T10:25:56.776Z"},content:{meta:{title:"Number()与parseInt()",time:"2018-02-03",tags:["JavaScript"]},html:'<p>Number()与parseInt()都是把非数值转换为数值的函数，其中，Number()的参数可以是任何类型，而parseInt()则只接受字符串类型</p>\n<h1 id="number">Number()</h1>\n<p>由于Number()所接受的参数类型没有限制，所以Number()对参数有多种处理方式：\n1、如果是布尔值，则true转换为1，false转换为0\n2、如果是数字值，则原样返回\n3、如果是null，则转换为0\n4、如果是undefined，则转换为NaN\n5、如果是字符串：\n（1）如果字符串中只包含数字（包括前面带正负号的），则将其转换为十进制数值，即”1”转换成1，”011”转换成11\n（2）如果字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数字（会忽略前导0）\n（3）如果字符串中包含有效的十六进制格式，例如”0xf”，则将其转换成相同大小的十进制整数值\n（4）如果字符串为空（””），则将其转换为0\n（5）如果字符串中上述格式以外的字符，则将其转换为NaN\n6、如果是对象，则调用对象中的valueof()方法，然后依照前面带规则转换返回的值，如果转换出来的值是NaN，则调用对象的toString()方法，然后再依照前面的规则转换返回的值</p>\n<p>示例：</p>\n<pre><code class="language-javascript">console.log(Number(&quot;str&quot;));  //NaN\nconsole.log(Number(&quot;012&quot;));  //12\nconsole.log(Number(true));  //1\nconsole.log(Number(&quot;&quot;));  //0\nconsole.log(Number(null));  //0\nconsole.log(Number(undefined));  //NaN\nconsole.log(Number(NaN));  // NaN</code></pre>\n<h1 id="parseint">parseInt()</h1>\n<p>parseInt()会忽略字符串前面的空格，当遇到不是空格的第一个字符不是数字字符或者负号，就会返回NaN，如果遇到的第一个非空格字符是数字字符，那么剩下的字符串中只要遇到非数字字符，剩下的字符都会被忽略</p>\n<pre><code class="language-javascript">console.log(parseInt(&quot;str&quot;));  //NaN\nconsole.log(parseInt(&quot;012&quot;));  //12\nconsole.log(parseInt(&quot;&quot;));  //NaN\nconsole.log(parseInt(&quot;  2&quot;));  //2\nconsole.log(parseInt(&quot;12str3&quot;));  //12</code></pre>\n<p>另外，parseInt()还可以传入第二个参数，为数字类型，表示按多少进制去解析字符串（第一个参数）：</p>\n<pre><code class="language-javascript">console.log(parseInt(&quot;010101&quot;, 2));  //21\nconsole.log(parseInt(&quot;AF&quot;, 16));  //175\nconsole.log(parseInt(&quot;70&quot;, 8));  //56</code></pre>\n<h1 id="parsefloat">parseFloat()</h1>\n<p>parseFloat()与parseInt()十分相似，只不过parseFloat()可以解析出浮点数，而parseInt()则不可以，但parseFloat()只能解析十进制值，对于十六进制的始终返回0，因此也没有第二个参数</p>\n<p>示例：</p>\n<pre><code class="language-javascript">console.log(parseFloat(&quot;11.2&quot;));  //11.2\nconsole.log(parseFloat(&quot;11.2.2&quot;));  //11.2\nconsole.log(parseFloat(&quot;.2&quot;));  //0.2\nconsole.log(parseFloat(&quot;..2&quot;));  //NaN\nconsole.log(parseFloat(&quot;012.1&quot;));  //12.1\nconsole.log(parseFloat(&quot;0xAF&quot;));  //0\nconsole.log(parseFloat(&quot;4.0&quot;));  //4\nconsole.log(parseFloat(&quot;12str3&quot;));  //12</code></pre>\n<p>parseFloat()还实现了部分parseInt()的功能，当需要解析的字符串是一个整数的字符串时，返回的也是整数</p>\n<pre><code class="language-javascript">console.log(parseFloat(&quot;123&quot;));  //123\nconsole.log(parseFloat(&quot;00123&quot;));  //123</code></pre>\n'}},"22f2ee2b":{name:"React+TypeScript+Antd+CSS Modules项目搭建",stat:{size:4550,mtime:"2020-12-13T13:45:28.479Z",birthtime:"2020-12-13T10:25:56.783Z"},content:{meta:{title:"React+TypeScript+Antd+CSS Modules项目搭建",time:"2019-08-04",tags:["JavaScript","React.js","TypeScript"]},html:'<p>基本环境：</p>\n<blockquote>\n<p>node版本：10.16.1</p>\n<p>yarn版本：1.17.3</p>\n</blockquote>\n<h1 id="新建typescript-react项目">新建TypeScript-React项目</h1>\n<p>安装CRA</p>\n<pre><code class="language-bash">npm install -g create-react-app</code></pre>\n<p>创建typescript-react项目</p>\n<pre><code class="language-bash">create-react-app my-app --typescript</code></pre>\n<h1 id="安装antd">安装Antd</h1>\n<pre><code class="language-bash">yarn add antd</code></pre>\n<h1 id="antd按需加载">Antd按需加载</h1>\n<pre><code class="language-diff">yarn add react-app-rewired customize-cra babel-plugin-import\n/* package.json */\n&quot;scripts&quot;: {\n-   &quot;start&quot;: &quot;react-scripts start&quot;,\n+   &quot;start&quot;: &quot;react-app-rewired start&quot;,\n-   &quot;build&quot;: &quot;react-scripts build&quot;,\n+   &quot;build&quot;: &quot;react-app-rewired build&quot;,\n-   &quot;test&quot;: &quot;react-scripts test&quot;,\n+   &quot;test&quot;: &quot;react-app-rewired test&quot;,\n}</code></pre>\n<p>然后在项目根目录创建一个 <code>config-overrides.js</code> 用于修改默认配置。</p>\n<pre><code class="language-javascript">// config-overrides.js\n\nconst { override, fixBabelImports } = require(&#39;customize-cra&#39;);\n\nmodule.exports = override(\n  fixBabelImports(&#39;import&#39;, {\n    libraryName: &#39;antd&#39;,\n    libraryDirectory: &#39;es&#39;,\n    style: &#39;css&#39;,\n  }),\n);</code></pre>\n<p>把<code>App.tsx</code>修改为如下内容：</p>\n<pre><code class="language-typescript">import React from &#39;react&#39;;\nimport { Button } from &#39;antd&#39;;\nimport &#39;./App.css&#39;;\n\nconst App: React.FC = () =&gt; {\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;Button type=&quot;primary&quot;&gt;Button&lt;/Button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;</code></pre>\n<p>让项目跑起来测试下：</p>\n<pre><code class="language-bash">yarn start</code></pre>\n<h1 id="antd自定义主题">Antd自定义主题</h1>\n<p>安装less、less-loader</p>\n<pre><code class="language-bash">yarn add less less-loader</code></pre>\n<p>修改<code>config-overrides.js</code>文件的内容：</p>\n<pre><code class="language-diff">// config-overrides.js\n\n- const { override, fixBabelImports } = require(&#39;customize-cra&#39;);\n+ const { override, fixBabelImports, addLessLoader } = require(&#39;customize-cra&#39;);\n\nmodule.exports = override(\n  fixBabelImports(&#39;import&#39;, {\n    libraryName: &#39;antd&#39;,\n    libraryDirectory: &#39;es&#39;,\n-   style: &#39;css&#39;,\n+   style: true,\n  }),\n+ addLessLoader({\n+   javascriptEnabled: true,\n+   modifyVars: { &#39;@primary-color&#39;: &#39;#1DA57A&#39; },\n+ }),\n);</code></pre>\n<p>详细的主题配置可以查看 <a href="https://ant.design/docs/react/customize-theme-cn">配置主题</a> 文档。</p>\n<p>让项目跑起来：</p>\n<pre><code class="language-bash">yarn start</code></pre>\n<h1 id="添加对sass的支持">添加对Sass的支持</h1>\n<pre><code class="language-bash">yarn add node-sass</code></pre>\n<h1 id="css-modules">CSS Modules</h1>\n<h2 id="原生css">原生css</h2>\n<p>参考<a href="https://rgm-89sc.github.io/2019/04/201904250926/">https://rgm-89sc.github.io/2019/04/201904250926/</a></p>\n<h2 id="scss">scss</h2>\n<p>1、把<code>App.css</code>文件重命名为<code>App.module.scss</code></p>\n<p>2、同目录下新建<code>App.module.scss.d.ts</code>，并写入以下内容：</p>\n<pre><code class="language-bash">export const App: string;</code></pre>\n<p>3、把<code>App.tsx</code>文件的内容改为：</p>\n<pre><code class="language-typescript">import React from &#39;react&#39;;\nimport { Button } from &#39;antd&#39;;\nimport * as styles from &#39;./App.module.scss&#39;;\n\nconst App: React.FC = () =&gt; {\n  return (\n    &lt;div className={styles[&#39;App&#39;]}&gt;\n      &lt;Button type=&quot;primary&quot;&gt;Button&lt;/Button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;</code></pre>\n<p>但上面的使用方法由于变量名不支持<code>-</code>符号，所以像<code>foo-bar</code>这样的css类名就无法被支持，不过我们可以把这些类名封装在一个对象里面：</p>\n<p>修改<code>App.module.scss.d.ts</code>：</p>\n<pre><code class="language-typescript">export default {\n  [&#39;App&#39;]: string,\n  [&#39;App-header&#39;]: string\n};</code></pre>\n<p>在<code>App.tsx</code>中引入<code>App.module.scss</code>的方式改为：</p>\n<pre><code class="language-typescript">import styles from &#39;./App.module.scss&#39;;</code></pre>\n<p>使用方式：</p>\n<pre><code class="language-html">&lt;div className={styles[&#39;App-header&#39;]}&gt;&lt;/div&gt;</code></pre>\n<p>如果不想每个组件或者页面都创建一个<code>.d.ts</code>文件、列出每个要导出的css类名，那可以直接在<code>react-app-env.d.ts</code>中添加声明，而在<code>.ts</code>文件中的使用方式不变：</p>\n<pre><code class="language-typescript">declare module &quot;*.module.scss&quot; {\n  const classes: { [key: string]: string };\n  export default classes;\n}</code></pre>\n<h2 id="less">less</h2>\n<p>在<code>react-app-env.d.ts</code>中添加声明：</p>\n<pre><code class="language-typescript">declare module &quot;*.module.less&quot; {\n  const classes: { [key: string]: string };\n  export default classes;\n}</code></pre>\n<p><code>config-overrides.js</code>增加3行：</p>\n<pre><code class="language-diff">const { override, fixBabelImports, addLessLoader } = require(&#39;customize-cra&#39;);\n\nmodule.exports = override(\n  fixBabelImports(&#39;import&#39;, {\n    libraryName: &#39;antd&#39;,\n    libraryDirectory: &#39;es&#39;,\n    style: true,\n  }),\n  addLessLoader({\n    javascriptEnabled: true,\n    modifyVars: {\n      &#39;@primary-color&#39;: &#39;#1DA57A&#39;\n    },\n\n+   strictMath: true,\n+   noIeCompat: true,\n+   localIdentName: &quot;[local]--[hash:base64:5]&quot;\n  }),\n);</code></pre>\n<p>在<code>.tsx</code>文件中的使用方式与scss的一致。</p>\n'}},aa335b5a:{name:"react-router给路由传递props",stat:{size:2e3,mtime:"2020-12-13T13:44:28.853Z",birthtime:"2020-12-13T10:25:56.792Z"},content:{meta:{title:"react-router给路由传递props",time:"2019-04-26",tags:["JavaScript","React.js"]},html:'<p>有时候我们可能要对子路由的状态进行提升，需要在父路由组件提供方法或变量以props的形式传递到所有子路由组件中，但我们又不能直接把父路由组件的方法或变量传递到&lt;Route&gt;中，因为这样将会是&lt;Route&gt;接收到父路由组件的方法或变量，并没有继续往下传递到子路由组件，所以在子路由组件中是获取不到父路由组件的这些方法或变量的。</p>\n<p>这时候&lt;Route&gt;的<a href="https://reacttraining.com/react-router/web/api/Route/render-func">render</a>属性就派上用场了，它接受一个函数，接收的参数是传递给&lt;Route&gt;的参数，返回值是一个新组件：</p>\n<pre><code class="language-javascript">{routes.map((route, index) =&gt; {\n    const RouteComponent = ({ component: Component, ...rest }) =&gt; (\n      &lt;Route {...rest} render={props =&gt; (\n        &lt;Component\n          {...props}\n        parentState={this.state}\n        parentFunc={this.parentFunc}\n      /&gt;\n    )} /&gt;\n  );\n\n      return (\n        &lt;RouteComponent\n          key={route.name}\n        path={route.path}\n        exact={route.exact}\n        component={route.component}\n      /&gt;\n    )\n})}</code></pre>\n<p>上面这个例子中是列表渲染多个&lt;Route&gt;使用组件RouteComponent进行包装，RouteComponent是一个函数组件，使用ES6的结构赋值分离传入RouteComponent的component和其他属性，然后利用<Route>的render属性把父组件的方法或变量以及原本该有的props传入到&lt;Component&gt;，将其他属性（rest）如path、exact等传给&lt;Route&gt;。</p>\n<p>这样，在子路由组件中就可以以<code>this.props[&#39;something&#39;]</code>的方式正常访问到父路由组件提供的方法或变量了：</p>\n<pre><code class="language-javascript">console.log(this.props.parentState);\nthis.props.parentFunc();</code></pre>\n<p>更简单的例子在<a href="https://reacttraining.com/react-router/web/api/Route/render-func">官方文档</a>。</p>\n'}},ebd46a56:{name:"Scrapy安装失败：Microsoft Visual C++ 14.0 is required",stat:{size:904,mtime:"2020-12-13T12:37:41.807Z",birthtime:"2020-12-13T10:25:56.798Z"},content:{meta:{title:"Scrapy安装失败：MicrosoftVisualC++14.0isrequired",time:"2019-02-08",tags:["Python"]},html:'<p>执行命令</p>\n<pre><code class="language-bash">pip install scrapy</code></pre>\n<p>后出现报错：Microsoft Visual C++ 14.0 is required导致安装失败，按照 <a href="https://www.scivision.co/python-windows-visual-c++-14-required/">https://www.scivision.co/python-windows-visual-c++-14-required</a> 中的解决方式没有得以解决，于是经过搜索发现是Scrapy的依赖twisted是需要编译的，那直接安装已编译的twisted就好了。</p>\n<p>在 <a href="https://www.lfd.uci.edu/~gohlke/pythonlibs">https://www.lfd.uci.edu/~gohlke/pythonlibs</a> 中找到Twisted这个包，挑选python版本和系统版本都合适的进行下载（cp后面的数字即为python版本，如cp37即为python3.7）。</p>\n<p>下载完成后使用pip安装这个whl文件</p>\n<pre><code class="language-bash">pip install &lt;whl文件的路径&gt;</code></pre>\n<p>安装完成后再安装scrapy</p>\n<pre><code class="language-bash">pip install scrapy</code></pre>\n'}},dc68a9ac:{name:"typeof与instanceof",stat:{size:2317,mtime:"2020-12-13T12:37:50.374Z",birthtime:"2020-12-13T10:25:56.805Z"},content:{meta:{title:"typeof与instanceof",time:"2018-02-03",tags:["JavaScript"]},html:'<p>typeof和instanceof都是用于检测数据类型的操作符，但它们的作用并不相同</p>\n<h1 id="typeof">typeof</h1>\n<p>typeof是一元操作符，求得一个变量或字面量的类型，使用方法：</p>\n<pre><code class="language-javascript">typeof a;  // 求得a的类型</code></pre>\n<p>在ES5标准中，typeof可能返回以下六种类型的字符串形式：\n“undefined” —–如果这个值未定义\n“boolean” ——-如果这个值是布尔值\n“string” ——–如果这个值是字符串\n“number” ——–如果这个值是数值\n“object” ——–如果这个值是对象或null\n“function” ——如果这个值是函数</p>\n<p>示例：</p>\n<pre><code class="language-javascript">console.log(typeof 1);  // number\nconsole.log(typeof &quot;str&quot;);  // string\nconsole.log(typeof true);  // boolean\nconsole.log(typeof function func(){});  // function\nconsole.log(typeof var1);  // undefined，var1未定义\nconsole.log(typeof undefined);  // undefined\nconsole.log(typeof NaN);  // number\nconsole.log(typeof null);  // object，null表示一个空对象指针\nconsole.log(typeof Math);  // object\nconsole.log(typeof Array);  // function</code></pre>\n<p>NaN虽然表示“非数值”，但它也是一个特殊的数字值，typeof并不能判断一个值是否是NaN，应当使用isNaN函数：</p>\n<pre><code class="language-javascript">console.log(isNaN(NaN));  // true\nconsole.log(isNaN(1));  // false</code></pre>\n<p>typeof Array返回的是function，故typeof无法判断一个值是否为数组，应当使用isArray函数：</p>\n<pre><code class="language-javascript">var arr = [], notArr = 1;\nconsole.log(Array.isArray(arr));  // true\nconsole.log(Array.isArray(notArr));  // false</code></pre>\n<h1 id="instanceof">instanceof</h1>\n<p>instanceof是二元操作符，instanceof的左边放需要检测的值，右边放类型，返回的是一个布尔值，若需要检测的值类型为操作符右边的类型时返回true，反之返回false，使用方法</p>\n<pre><code class="language-javascript">a instanceof b;</code></pre>\n<p>示例：</p>\n<pre><code class="language-javascript"> var o = {},\n    arr = [];\nconsole.log(o instanceof Object);  // true\nconsole.log(arr instanceof Array);  // true</code></pre>\n<h1 id="总结">总结</h1>\n<p>typeof更适合用来检测基本类型（Undefined、Null、Boolean、Number、String），而instanceof适合用来检测引用类型（Object、Array、Function、RegExp）</p>\n'}},c182f1f9:{name:"VS Code解决格式化Vue代码时单引号变双引号",stat:{size:727,mtime:"2020-12-13T12:37:57.703Z",birthtime:"2020-12-13T10:25:56.811Z"},content:{meta:{title:"VSCode解决格式化Vue代码时单引号变双引号",time:"2019-01-01",tags:["Vue.js"]},html:'<h1 id="问题描述">问题描述</h1>\n<p>习惯于在JS中使用单引号而非双引号来表示字符串，但在VS code中写Vue单文件组件，格式化代码时却发现VS Code会自动把JS代码中的单引号都转变为双引号。</p>\n<h1 id="问题解决">问题解决</h1>\n<p>进入用户设置，找到Vetur扩展插件中的默认格式化设置：</p>\n<p><img src="https://s3.ax1x.com/2020/12/13/re7UgA.png" alt="img"></p>\n<p>在setting.json中编辑，增加一个”prettier”属性并把”singleQuote”设置成true：</p>\n<p><img src="https://s3.ax1x.com/2020/12/13/re7ajI.png" alt="img"></p>\n<p>这时再对.vue文件格式化时，VS Code就会把双引号格式化成单引号了。</p>\n'}},f62988f4:{name:"使用frp进行内网穿透并通过自定义域名访问内网Vue应用",stat:{size:3418,mtime:"2020-12-13T12:34:16.610Z",birthtime:"2020-12-13T10:25:56.899Z"},content:{meta:{title:"使用frp进行内网穿透并通过自定义域名访问内网Vue应用",time:"2018-10-18",tags:["内网穿透"]},html:'<p>摘自：<a href="https://github.com/fatedier/frp/blob/master/README_zh.md">frp中文文档</a>：</p>\n<blockquote>\n<p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。</p>\n<p>frp可以利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。</p>\n<p>对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。</p>\n<p>利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。</p>\n</blockquote>\n<p>有了frp，我们就可以使用自定义域名访问内网的web应用，下面这个例子是使用frp进行内网穿透，外网访问内网的Vue应用：</p>\n<h1 id="下载frp">下载frp</h1>\n<p>进入frp的releases页面：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p>\n<p>挑选合适的版本进行下载，比如客户机的操作系统是win 10 64位则下载windows_amd64版本，拥有公网ip的服务器是Ubuntu，CPU架构是X86_64则下载linux_amd64版本</p>\n<p>然后将 <strong>frps</strong> 及 <strong>frps.ini</strong> 放到具有公网 IP 的机器上， <strong>frpc</strong> 及 <strong>frpc.ini</strong> 放到处于内网环境的机器上。</p>\n<h1 id="在拥有公网ip的机器上配置frpsini">在拥有公网ip的机器上配置frps.ini:</h1>\n<p>解压tar.gz文件：</p>\n<pre><code class="language-bash">tar -xvf ./frp_0.21.0_linux_amd64.tar.gz</code></pre>\n<p>配置frps.ini：</p>\n<pre><code class="language-ini">; frps.ini\n[common]\nbind_port = 9000\n; bind_port是frp在拥有公网ip的机器上运行的端口，默认为7000\nvhost_http_port = 8082\n; vhost_http_port是http访问端口，默认为8080\n; 如果想使用https则把vhost_http_port改成vhost_https_port即可</code></pre>\n<p>配置完成后启动frps：</p>\n<pre><code class="language-bash">./frps -c ./frps.ini</code></pre>\n<p>如果出现报错：-bash: ./frps: cannot execute binary file: Exec format error则是表明版本下载错了</p>\n<p>然后开放这些端口的访问（比如阿里云的服务器可以在安全组配置中开放端口），将 <code>www.yourdomain.com</code> 的域名 A 记录解析到 IP <code>x.x.x.x</code>，如果服务器已经有对应的域名，也可以将 CNAME 记录解析到服务器原先的域名</p>\n<h1 id="在内网环境机器上配置frpcini">在内网环境机器上配置frpc.ini</h1>\n<pre><code class="language-ini">; frpc.ini\n[common]\nserver_addr = x.x.x.x\n; 服务器的公网ip\nserver_port = 9000\n; server_port于你在拥有公网ip的机器上的frps.ini中的bind_port相同\n\n[web]\ntype = http\n; 如果使用https则写成https\nlocal_port = 8082\n; 本地开放http访问的端口\ncustom_domains = www.yourdomain.com\n; 访问域名</code></pre>\n<p>配置完成后启动frpc：</p>\n<pre><code class="language-bash">./frpc -c ./frpc.ini</code></pre>\n<p>在windows下还可以在cmd中运行frpc.exe</p>\n<h1 id="从外网访问内网web服务">从外网访问内网web服务</h1>\n<p>打开浏览器，通过 协议://域名:端口号 访问内网web服务就OK了</p>\n<p>但是如果访问的是Vue应用，那还需要多配置一些东西</p>\n<p>dev模式下启动Vue应用之后再外网访问内网会返回<strong>invalid host header</strong>，这是因为webpack会检查hostname，如果hostname不在配置内，就会拒绝这个访问</p>\n<p>解决办法：在vue.config.js中加上devServer配置：</p>\n<pre><code class="language-javascript">module.exports = {\n  devServer: {\n    disableHostCheck: true\n  },\n}</code></pre>\n<p>关于devServer的详细，可以查看Vue-cli的配置参考文档：<a href="https://cli.vuejs.org/zh/config/#devserver">https://cli.vuejs.org/zh/config/#devserver</a></p>\n'}},"8e2c68fa":{name:"使用Node JS在控制台打印自定义前后景颜色的字符串",stat:{size:2240,mtime:"2020-12-13T13:14:34.382Z",birthtime:"2020-12-13T10:25:56.906Z"},content:{meta:{title:"使用NodeJS在控制台打印自定义前/后景颜色的字符串",time:"2018-12-06",tags:["Node.js","ASNI"]},html:'<p>参考链接：<a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Colors">https://en.wikipedia.org/wiki/ANSI_escape_code#Colors</a></p>\n'}},c84bbb32:{name:"全局监听异常的方式",stat:{size:1773,mtime:"2021-01-24T06:14:39.872Z",birthtime:"2021-01-30T10:34:48.190Z"},content:{meta:{title:"全局监听异常的方式",time:"2020-12-04",tags:["JavaScript"]},html:'<p>有时候我们并不能完全保证代码逻辑都不会出错，或者在需要的地方都做好了异常捕获的处理，这时候就能通过监听全局的异常时间来处理我们预料之外的异常了。</p>\n<h2 id="windowonerror">window.onerror</h2>\n<pre><code class="language-javascript">window.onerror = function (message, source, lineno, colno, error) {\n    // ...\n}</code></pre>\n<p>参数介绍：</p>\n<ul>\n<li>message：错误提示信息</li>\n<li>source：错误脚本地址</li>\n<li>lineno：错误代码所在行号</li>\n<li>colno：错误代码所在列号</li>\n<li>error：错误的对象信息</li>\n</ul>\n<p>如果要在window.onerror中处理消化掉异常，就需要return true，使得错误不会继续往上抛。</p>\n<p>window.onerror是通过事件冒泡来捕获异常的，无论对于异步还是同步的错误，它都能捕获运行时错误，但无法获取语法错误，也无法捕获网络错误（网络请求异常不会发生冒泡）。</p>\n<p>对于不同域的脚本，window.onerror在很多浏览器中也无法捕获异常，这时需要对脚本的script标签设置</p>\n<pre><code class="language-javascript">crossorigin=&quot;anonymous&quot;\n// crossorigin 或 crossorigin=&quot;&quot;，和设置 anonymous 的效果一样</code></pre>\n<p>在script与link标签上还有一个onerror属性，但它只能监听网络请求的错误</p>\n<pre><code class="language-html">&lt;script src=&quot;***.js&quot; onerror=&quot;errorHandler(this)&quot;&gt;&lt;/script&gt;</code></pre>\n<h2 id="windowaddeventlistenererror">window.addEventListener(&#39;error&#39;)</h2>\n<p>window.addEventListener(&#39;error&#39;)与window.onerror不同，它是通过事件捕获来获取异常的，能获取到网络请求错误</p>\n<pre><code class="language-javascript">window.addEventListener(&#39;error&#39;, function (error) {\n    if (!error.message) {\n        // 当没有error.message时为网络资源加载错误\n    } else {\n\n    }\n})</code></pre>\n'}},c70cf347:{name:"函数防抖与函数节流",stat:{size:3302,mtime:"2020-12-13T12:33:27.601Z",birthtime:"2020-12-13T10:25:56.872Z"},content:{meta:{title:"函数防抖与函数节流",time:"2019-03-04",tags:["JavaScript"]},html:'<h1 id="函数防抖">函数防抖</h1>\n<p>函数防抖是指持续地触发某个功能函数都不会立即执行该功能函数，而是等到某一段时间内再也没有触发时再执行，可以应用在有大量操作或者需要发送Ajax请求的事件处理函数上，如果事件触发非常频繁，那么频繁触发事件处理函数就会造成用户体验非常不好，也浪费资源，函数防抖就可以很好解决这个问题：</p>\n<pre><code class="language-javascript">function debounce(handle, delay) {\n  let timer;\n  return () =&gt; {\n    clearTimeout(timer);\n    timer = setTimeout(handle, delay);\n  };\n}\n\nfunction mousemoveHandle() {\n  console.log(&#39;stop move&#39;);\n}\n\ndocument.getElementById(&#39;my-div&#39;).addEventListener(&#39;mousemove&#39;, debounce(mousemoveHandle, 1000));</code></pre>\n<p>假设我们现在有一个id为”my-div”的div元素，监听用户的鼠标是否在这个div上停留够1秒钟。debounce函数就是实现防抖功能的函数，它接收两个参数：handle和delay，handle是真正的事件处理函数，delay是延迟调用handle的毫秒数；当事件不断触发时，debounce函数中的timer变量也不断被clearTimeout函数清空，并重新设定定时器，当不再触发事件1秒后定时器会正常工作。</p>\n<h2 id="修正this指向与接收事件对象">修正this指向与接收事件对象</h2>\n<p>但上面的代码还有两个问题：this的指向由触发事件的DOM对象变成了全局window，事件处理函数的默认传参event对象也无法在真正的事件处理函数中获取，为解决这个问题就需要在debounce函数所返回的函数中修正this，并接收event对象，所以应当把箭头函数改用成普通的函数声明：</p>\n<pre><code class="language-javascript">function debounce(handle, delay) {\n  let timer;\n  return function(event) {\n    clearTimeout(timer);\n    timer = setTimeout(handle.bind(this, event), delay);\n  };\n}\n\nfunction mousemoveHandle(event) {\n  console.log(this);\n  console.log(event);\n}\n\ndocument.getElementById(&#39;my-div&#39;).addEventListener(&#39;mousemove&#39;, debounce(mousemoveHandle, 1000));</code></pre>\n<p>这样this的指向就正常了，event对象也能成功接收。</p>\n<h1 id="函数节流">函数节流</h1>\n<p>函数节流的概念与函数防抖有点相似，但函数防抖是当一段时间内不再触发功能函数时才执行功能函数，而函数节流是无论怎么频繁触发功能函数，功能函数都只会在某一段时间内执行一次：</p>\n<pre><code class="language-javascript">function throttle(handle, delay) {\n  let start = Date.now();\n  return function(event) {\n    const now = Date.now();\n    if (now - start &gt;= delay) {\n      handle.call(this, event);\n      start = Date.now();\n    }\n  };\n}\n\nfunction mousemoveHandle(event) {\n  console.log(this);\n  console.log(event);\n}\n\ndocument.getElementById(&#39;my-div&#39;).addEventListener(&#39;mousemove&#39;, throttle(mousemoveHandle, 1000));</code></pre>\n<p>在事件注册时，throttle函数就会记录下当前时间戳，当事件触发时就会把触发时的当前时间戳减去之前记录下的时间戳，如果比delay大或者相等则可以“放行”，执行真正的事件处理函数并重新记录下当前时间戳作为当前该事件触发完成的时间，当下一次事件触发时就可以将其作为上一次事件触发的时间了。</p>\n'}},"3c7cbe1d":{name:"删除多个元素的类名时类名被成功删除的元素只占了一半？",stat:{size:1921,mtime:"2020-12-13T12:34:02.561Z",birthtime:"2020-12-13T10:25:56.892Z"},content:{meta:{title:"删除多个元素的类名时类名被成功删除的元素只占了一半？",time:"2018-01-23",tags:["JavaScript"]},html:'<p>如图，我将要删除class属性为”tag”的li标签的class属性值\n<img src="https://s3.ax1x.com/2020/12/13/reL7e1.png" alt="img">\n代码：</p>\n<pre><code class="language-javascript">let tags = document.getElementsByClassName(&quot;tag&quot;);\nfor(let i = 0; i &lt; tags.length; i++){\n    tags[i].className = &quot;&quot;;\n}</code></pre>\n<p>当使用for循环把各个带”tag”类名的p标签的类名置为””时，只成功把一半数量的className删除掉：\n<img src="https://s3.ax1x.com/2020/12/13/reLLFK.png" alt="img">\n为什么？我们先来试试在每次把className置为””前在控制台打印一下tags和i</p>\n<pre><code class="language-javascript">let tags = document.getElementsByClassName(&quot;tag&quot;);\nfor(let i = 0; i &lt; tags.length; i++){\n    console.log(tags);\n    console.log(i);\n    tags[i].className = &quot;&quot;;\n}</code></pre>\n<p><img src="https://s3.ax1x.com/2020/12/13/reLvSe.png" alt="img">\n可以看见，每把一个元素的className置为””，tages这个元素集合的length属性值就会-1，这里共有6个p标签的className需要被置””，而当把tags中的第4个元素的className置为””，即i的值为3时，tags的长度已经变为3，所以此时会退出循环，这样就只把一半数量的className删掉了</p>\n<p>解决办法：</p>\n<pre><code class="language-javascript">let tags = document.getElementsByClassName(&quot;tag&quot;);\nfor(let i = tags.length - 1; i &gt;= 0; i--){\n    tags[i].className = &quot;&quot;;\n}</code></pre>\n<p>同样的，我们在循环中打印一下tags和i：\n<img src="https://s3.ax1x.com/2020/12/13/reLzyd.png" alt="img">\n从输出结果来看一切正常，并且，成功把所有要删除的className删除了：\n<img src="https://s3.ax1x.com/2020/12/13/reOSOA.png" alt="img"></p>\n<p>这次i是从tags的长度-1开始，每次循环都把tags中最后一个元素的className置为””，直到tags中没有元素了就是已经把需要删除的className全部删除了</p>\n'}},"552e6081":{name:"原型链",stat:{size:913,mtime:"2021-02-14T14:50:41.502Z",birthtime:"2020-10-30T14:58:41.229Z"},content:{meta:{title:"",time:"",tags:[]},html:'<h1 id="原型链">原型链</h1>\n<p>所有对象都有<code>__proto__</code>属性，但只有函数对象（不只是内置的Object、Function、Array、Date、String等，实际上每个 JavaScript 函数都是一个 <code>Function</code> 对象）才有<code>prototype</code>属性</p>\n<p>但通过Function.prototype.bind方法构造出来的函数是个例外，它没有prototype属性，<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4.5">详情</a></p>\n<blockquote>\n<p>Function objects created using <code>Function.prototype.bind</code> do not have a <code>prototype</code> property or the [[Code]], [[FormalParameters]], and [[Scope]] internal properties.</p>\n</blockquote>\n<p><code>__proto__</code>属性（隐式原型）指向构造该对象的构造函数的原型对象（prototype，显式原型），但<code>Object.prototype</code>的<code>__proto__</code>是<code>null</code>。</p>\n<p><code>__proto__</code>有两个属性：</p>\n<ul>\n<li>constructor，一般指向该对象的构造函数</li>\n<li>__proto__</li>\n</ul>\n<p><code>prototype</code>属性指向函数的原型对象</p>\n'}},e323ff3e:{name:"变量声明提升与函数声明提升",stat:{size:1346,mtime:"2020-12-13T12:32:23.404Z",birthtime:"2020-12-13T10:25:56.826Z"},content:{meta:{title:"变量声明提升与函数声明提升",time:"2018-02-08",tags:["JavaScript"]},html:'<h1 id="变量声明提升">变量声明提升</h1>\n<p>变量声明提升是指变量的声明会被提到作用域的顶部，但其赋值并不会跟着提升</p>\n<pre><code class="language-javascript">console.log(a);</code></pre>\n<p>在没用定义变量的时候就访问会导致错误：”a is not defined”\n如果这时在访问语句后面声明变量并赋值：</p>\n<pre><code class="language-javascript">console.log(a);  //undefined\nvar a = 1;</code></pre>\n<p>可以看到输出undefined，这是因为变量a的声明被提升了，而赋值并没有随着被提升，被声明的变量在没有被赋值的情况下会获得undefined这个值，相当于：</p>\n<pre><code class="language-javascript">var a;\nconsole.log(a);  //undefined\na = 1;</code></pre>\n<h1 id="函数声明提升">函数声明提升</h1>\n<p>函数声明也会提升，但它是把函数体也跟着提升：</p>\n<pre><code class="language-javascript">hello();  //Hello\nfunction hello(){\n    console.log(&quot;Hello&quot;);\n}</code></pre>\n<p>上面这个例子等价于</p>\n<pre><code class="language-javascript">function hello(){\n    console.log(&quot;Hello&quot;);\n}\nhello();  //Hello</code></pre>\n<p>我们知道，创建一个函数也可以使用函数表达式的方式，但这样就和变量提升一样，赋值部分不会提升，即函数体不会随着提升：</p>\n<pre><code class="language-javascript">hello();  //error: hello is not a function\nvar hello = function(){\n    console.log(&quot;Hello&quot;);\n}</code></pre>\n'}},"9f681db8":{name:"在Vue-cli中使用axios",stat:{size:807,mtime:"2020-12-13T13:14:48.693Z",birthtime:"2020-12-13T10:25:56.935Z"},content:{meta:{title:"在Vue-cli中使用axios",time:"2018-10-18",tags:["JavaScript","Vue.js"]},html:'<p>在Vue-cli中安装使用axios并非使用Vue add和Vue.use()，那怎么在Vue-cli中正确安装使用呢？</p>\n<p>首先使用npm安装axios：</p>\n<pre><code class="language-bash">npm install --save axios</code></pre>\n<p>在main.js中导入axios并把axios挂到Vue的原型上去：</p>\n<pre><code class="language-javascript">// main.js\nimport axios from &#39;axios&#39;;\n\nVue.prototype.$axios = axios;</code></pre>\n<p>这里我使用了$axios作为变量名，是因为这样能避免在组件中使用时会把axios错认成是组件的$data中的变量</p>\n<p>接下来就可以在组件中使用axios了：</p>\n<pre><code class="language-javascript">this.$axios({\n  method: &#39;post&#39;,\n  url: &#39;{{url}}&#39;,\n  /* Some code */\n}).then((res) =&gt; {\n  /* Some code */\n}).catch((err) =&gt; {\n  /* Some code */\n});</code></pre>\n'}},d812960a:{name:"如何在Vue-cli的列表渲染中写静态图片路径",stat:{size:1744,mtime:"2020-12-13T13:14:24.212Z",birthtime:"2020-12-13T10:25:56.886Z"},content:{meta:{title:"如何在Vue-cli的列表渲染中写静态图片路径",time:"2018-11-15",tags:["JavaScript","Vue.js"]},html:'<p>在vue-cli中我们可以通过</p>\n<pre><code class="language-vue">&lt;img src=&quot;../assets/img1.jpg&quot;&gt;</code></pre>\n<p>或</p>\n<pre><code class="language-vue">&lt;img src=&quot;@img/img.png&quot;&gt;</code></pre>\n<p>或</p>\n<pre><code class="language-vue">&lt;img src=&quot;~img/img.png&quot;&gt;</code></pre>\n<p>等这样的方式进行引入本地图片资源，这些都有在<a href="https://cli.vuejs.org/zh/guide/html-and-static-assets.html#%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8">官方文档</a>提到</p>\n<p>除此之外，对于列表渲染还可以使用CommonJS规范的require()来引入图片：</p>\n<pre><code class="language-vue">&lt;template&gt;\n  &lt;ul&gt;\n    &lt;li v-for=&quot;(img, index) in imgURL&quot; \n      :key=&quot;index&quot; \n      v-show=&quot;index === mark&quot; \n      :style=&quot;{ backgroundImage: &#39;url(&#39; + img + &#39;)&#39; }&quot; \n      class=&quot;slideitem&quot;&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      imgURL: [\n        require(&quot;../assets/1305120757455173.jpg&quot;),\n        require(&quot;../assets/1305120805172589.jpg&quot;),\n        require(&quot;../assets/H3c.jpg&quot;),\n        require(&quot;../assets/H3C2.jpg&quot;)\n      ],\n    };\n  }\n}\n&lt;/script&gt;</code></pre>\n<p>在vue-cli中所有诸如 <code>&lt;img src=&quot;...&quot;&gt;</code>、<code>background: url(...)</code> 和 CSS <code>@import</code> 的资源 URL 都会被解析为一个模块依赖，还有URL以./、@、~开头的都会认为是一个模块请求，即会被转化为 <code>require(...)</code>，所以直接使用require()是完全没问题的。</p>\n<p>而在public文件夹中的资源就不能用相对路径来引入了，因为public文件夹的中的资源编译时都不会被webpack所处理，在官方文档中不推荐把静态资源都放到public中，public文件夹这一解决方案应当作为应急而使用，关于public文件夹的详细说明可以查看官方文档。</p>\n'}},a6b81d7e:{name:"富文本编辑器ckeditor使用ckfinder上传图片",stat:{size:2023,mtime:"2020-12-13T12:33:08.332Z",birthtime:"2020-12-13T10:25:56.859Z"},content:{meta:{title:"富文本编辑器ckeditor使用ckfinder上传图片",time:"2019-03-24",tags:["JavaScript"]},html:'<p>我在使用vue+ckeditor+ckfinder做一个上传图片的功能时踩到了坑：图片已经上传到服务器了，但在前端会弹出alert提示图片上传失败，所以记录下来以防以后再踩一次。</p>\n<p>首先先把ckeditor作为组件导入，然后根据<a href="https://ckeditor.com/docs/ckeditor5/latest/features/image-upload/ckfinder.html">ckfinder的文档</a>导入CKFinder：</p>\n<pre><code class="language-javascript">import CKFinder from &#39;@ckeditor/ckeditor5-ckfinder/src/ckfinder&#39;;</code></pre>\n<p>在vue的组件data中配置好ckfinder：</p>\n<pre><code class="language-javascript">export default {\n  data() {\n    return {\n      editorConfig: {\n        plugins: [\n          CKFinder,\n          ...\n        ],\n\n        toolbar: {\n          items: [\n            &#39;imageUpload&#39;,\n              ...\n          ]\n        },\n\n        ckfinder: {\n          // Upload the images to the server using the CKFinder QuickUpload command.\n          uploadUrl: &#39;上传图片的后台接口地址&#39;,\n          options: {\n            resourceType: &#39;.jpg,.jpeg,.png&#39;  // 允许上传的图片后缀名\n          }\n        }\n      }\n    };\n  },\n}</code></pre>\n<p>把editorConfig传给ckeditor组件（editor是导入的ckeditor，editorData是富文本字符串，相关文档：<a href="https://ckeditor.com/docs/ckeditor5/latest/builds/guides/integration/frameworks/vuejs.html">Rich text editor component for Vue.js</a>）：</p>\n<pre><code class="language-vue">&lt;ckeditor :editor=&quot;editor&quot; v-model=&quot;editorData&quot; :config=&quot;editorConfig&quot;&gt;&lt;/ckeditor&gt;</code></pre>\n<p>这样，前端方面就基本没有问题了，剩下的是后端，后端接口把上传的图片存起来后需要返回特定的数据格式：</p>\n<pre><code class="language-javascript">{\n  uploaded: 1, // 写死，不需要改\n  fileName: &#39;filename&#39;, // 图片名\n  url: &#39;https://example.com/image/url&#39;  //上传到后台后可访问的图片的url\n}</code></pre>\n<p>否则，如果返回的数据格式不对，在前端就会alert提示图片上传失败。</p>\n'}},f7c9bc49:{name:"对splice()、slice()、split()的梳理",stat:{size:3361,mtime:"2020-12-13T12:32:58.390Z",birthtime:"2020-12-13T10:25:56.838Z"},content:{meta:{title:"对splice()、slice()、split()的梳理",time:"2018-03-16",tags:["JavaScript"]},html:'<p>最近发现自己对splice()、slice()、split()这三个方法有点混淆了，故做个梳理</p>\n<h1 id="splice">splice()</h1>\n<p>splice()是挂在Array.prototype上的方法，可以用来删除或增加或替换数组元素，splice()的返回值始终为一个数组，是被删除项的集合，如果splice()没有删除项，则返回的是一个空数组</p>\n<h2 id="删除">删除</h2>\n<p>如果要让splice()方法实现删除数组元素的功能只需要两个参数，第一个参数为要删除的第一项的位置，第二个参数为要删除的项数，比如：删除数组中的前两项：</p>\n<pre><code class="language-javascript">var arr = [1, 2, 3, 4, 5];\narr.splice(0, 2);\nconsole.log(arr);  //[3, 4, 5]</code></pre>\n<h2 id="插入">插入</h2>\n<p>如果要让splice()方法实现插入数组元素的功能需要三个参数，第一个参数为要删除的第一项的位置，第二个参数为要删除的项数（此时需为0），第三个参数为要插入的项，如果要插入多个项，则还可以有第四、五、六······个项，比如：在数组的开头插入两项：</p>\n<pre><code class="language-javascript">var arr = [1, 2, 3, 4, 5];\narr.splice(0, 0, -1, 0);\nconsole.log(arr);  //[-1, 0, 1, 2, 3, 4, 5]</code></pre>\n<h2 id="替换">替换</h2>\n<p>如果要让splice()方法实现替换数组元素的功能也需要三个参数，一个参数为要删除的第一项的位置，第二个参数为要删除的项数，第三个参数为要替换的项，如果要替换成多个项，则还可以有第四、五、六······个项，比如：把数组中第一个元素替换成两项：</p>\n<pre><code class="language-javascript">var arr = [1, 2, 3, 4, 5];\narr.splice(0, 1, -1, 0);\nconsole.log(arr);  //[-1, 0, 2, 3, 4, 5]</code></pre>\n<h1 id="slice">slice()</h1>\n<p>slice()也是挂在Array.prototype上的方法，slice()会返回一个新数组，不改变原数组，这个新数组是原数组从起始位置（第一个参数）到结束位置（第二个参数）的前一个位置的一个浅复制（新数组中的元素地址其实还是与原数组中的相同）</p>\n<p>示例：</p>\n<pre><code class="language-javascript">var arr = [1, 2, 3, 4, 5];\nvar arrcopy = arr.slice(0, 4);\nconsole.log(arrcopy);  //[1, 2, 3, 4]</code></pre>\n<h1 id="split">split()</h1>\n<p>split()是挂在String.prototype上的方法，作用是利用分隔符对字符串进行分割，该方法有两个参数，第一个参数是分隔符，为正则表达式，第二个参数是可选的，为一个整数，限定返回的分割片段数量</p>\n<p>示例（获取一个字符串中的所有单词）：</p>\n<pre><code class="language-javascript">var str = &quot;The arts is a vast subdivision of culture&quot;;\nvar arr = str.split(&quot; &quot;);\nconsole.log(arr);  //[&#39;The&#39;, &#39;arts&#39;, &#39;is&#39;, &#39;a&#39;, &#39;vast&#39;, &#39;subdivision&#39;, &#39;of&#39;, &#39;culture&#39;]</code></pre>\n<p>当分隔符为空（第一个参数为””）时，会把所有字符都分割出来：</p>\n<pre><code class="language-javascript">var str = &quot;The arts is a vast subdivision of culture&quot;;\nvar arr = str.split(&quot;&quot;);\nconsole.log(arr);  //[ &#39;T&#39;, &#39;h&#39;, &#39;e&#39;, &#39; &#39;, &#39;a&#39;, &#39;r&#39;, &#39;t&#39;, &#39;s&#39;, &#39; &#39;, &#39;i&#39;, &#39;s&#39;, &#39; &#39;, &#39;a&#39;, &#39; &#39;, &#39;v&#39;, &#39;a&#39;, &#39;s&#39;, &#39;t&#39;, &#39; &#39;, &#39;s&#39;, &#39;u&#39;, &#39;b&#39;, &#39;d&#39;, &#39;i&#39;, &#39;v&#39;, &#39;i&#39;, &#39;s&#39;, &#39;i&#39;, &#39;o&#39;, &#39;n&#39;, &#39; &#39;, &#39;o&#39;, &#39;f&#39;, &#39; &#39;, &#39;c&#39;, &#39;u&#39;, &#39;l&#39;, &#39;t&#39;, &#39;u&#39;, &#39;r&#39;, &#39;e&#39; ]</code></pre>\n<p>另外要注意的是，当字符串为空时，split()返回一个包含一个空字符串的数组，而不是一个空数组，如果字符串和分隔符都是空字符串，则返回一个空数组</p>\n'}},"6f3b3f28":{name:"对象属性的数据属性与访问器属性",stat:{size:6814,mtime:"2020-12-13T12:32:45.950Z",birthtime:"2020-12-13T10:25:56.845Z"},content:{meta:{title:"对象属性的数据属性与访问器属性",time:"2018-02-06",tags:["JavaScript"]},html:'<p> |\n| [[Configurable]] | 表示能否使用delete删除属性，能否修改为访问器属性 | true      |\n| [[Enumerable]]   | 表示能否通过for-in枚举出来                       | true      |\n| [[Get]]          | 在读取属性时调用的函数                           | undefined |\n| [[Set]]          | 在写入属性时调用的函数                           | undefined |</p>\n<p>访问器属性不包含数据值，当读取访问器属性时会调用getter函数，这个函数负责返回有效的值；当写入访问器属性时会调用setter函数并传入新的值\n只定义getter函数时意味着属性不可写，只定义setter函数时意味着属性不可读\n当使用了getter或setter方法，就不允许使用writable和value这两个属性了</p>\n<p>不同于数据属性，访问器属性是不能直接定义的，只能通过Object.defineProperty()来定义</p>\n<p>示例：</p>\n<pre><code class="language-javascript">var obj = {\n    var1: &quot;var1&quot;\n};\n\nObject.defineProperty(obj, &quot;var1&quot;, {\n    get: function(){\n        return this._var1;\n    },\n    set: function(value){\n        this._var1 = value;\n    }\n});\nobj.var1 = &quot;var0&quot;;\nconsole.log(obj.var1);</code></pre>\n<p>在上面这个例子中第7行和第10行的var1前面都加上了一个下划线符号”_”，这个下划线表示这个属性只能通过对象方法访问\n而如果不加会有什么问题呢？\n抛出错误：”Maximum call stack size exceeded”，超过了最大调用堆栈大小</p>\n<p>原因是：getter和setter函数分别访问、修改this.var1，也就是需要读取修改var1，这就需要调用getter和setter函数了，如此递归调用最后超过了最大调用堆栈大小，抛出错误</p>\n<p>访问器属性一般是使用在设置一个属性值是也让其他属性值变化，但我们也可以不用访问器属性实现</p>\n<h1 id="定义多个属性">定义多个属性</h1>\n<p>Object.defineProperty()只能定义一个对象属性的特性，而Object.defineProperties()可以一次性定义多个对象属性的特性，这个方法只接受两个参数：第一个参数是要添加和修改其属性的对象，第二个参数也是对象，这个对象是要修改的属性名与其特性描述符对象的集合</p>\n<p>示例：</p>\n<pre><code class="language-javascript">var obj = {};\n\nObject.defineProperties(obj, {\n    var1: {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: &quot;var1&quot;\n    },\n    var2: {\n        configurable: true,\n        enumerable: true,\n        get: function(){\n            return this._var2;\n        },\n        set: function(value){\n            this._var2 = value;\n        }\n    }\n});\n\nconsole.log(obj.var1);  //var1\nconsole.log(obj.var2);  //undefined\nobj.var2 = &quot;var2&quot;;\nconsole.log(obj.var2);  //var2</code></pre>\n<h1 id="读取属性的特性">读取属性的特性</h1>\n<p>Object.getOwnPropertyDescriptor()可以取得给定属性的描述符对象，这个方法的返回值是一个对象，接受两个参数：属性所在的对象、要读取其描述符的属性名称</p>\n<p>示例（接上一个例子）：</p>\n<pre><code class="language-javascript">var descriptor = Object.getOwnPropertyDescriptor(obj, &quot;var1&quot;);\nconsole.log(descriptor.configurable);  //true\nconsole.log(descriptor.enumerable);  //true\nconsole.log(descriptor.writable);  //true\nconsole.log(descriptor.value);  //var1\nconsole.log(descriptor.get);  //undefined\nconsole.log(descriptor.set);  //undefined</code></pre>\n'}},dd7f6e8c:{name:"尺寸与坐标",stat:{size:5132,mtime:"2020-12-13T12:32:34.175Z",birthtime:"2020-12-13T10:25:56.831Z"},content:{meta:{title:"尺寸与坐标",time:"2018-12-22",tags:["JavaScript"]},html:'<h1 id="文档坐标">文档坐标</h1>\n<p>想要获取文档的坐标需要用到window下的pageXOffset 和 pageYOffset 属性，返回文档在窗口左上角水平和垂直方向滚动的像素（文档滚动条的位置）。</p>\n<p>调用方法</p>\n<pre><code class="language-javascript">window.pageXOffset;\nwindow.pageYOffset;</code></pre>\n<p>这两个属性的返回值默认都为0，而当页面滚动（向上或向下）后，这两个属性的值就发生变化。</p>\n<p>虽然这两个属性被各浏览器广泛支持，但IE8及以下版本是不支持的，但有功能相同的属性：scrollLeft和scrollTop，在标准模式下通过document.documentElement获取，在怪异模式下通过document.body获取。所以，获取文档滚动条位置可以这么写：</p>\n<pre><code class="language-javascript">function getScrollOffsets () {\n  if (window.pageXOffset != null) {\n    return {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n\n  // 标准模式下的IE\n  var d = document;\n  if (document.compatMode === &#39;CSS1Compat&#39;) {\n    return {\n      x: d.documentElement.scrollLeft,\n      y; d.documentElement.scrollTop\n    };\n  }\n\n  // 怪异模式下的浏览器\n  return {\n    x: d.body.scrollLeft,\n    y: d.body.scrollTop\n  };\n}</code></pre>\n<p>scrollLeft和scrollTop不仅可以当做pageXOffset和pageYOffset使用，它们还是可写属性，可以设置它们来让元素中的内容滚动（元素并没有window对象的scrollTo()和scrollBy()方法）。</p>\n<h1 id="视口尺寸">视口尺寸</h1>\n<p>window.innerHeight可以返回窗口的文档显示区的高度，window.innerWidth可以返回窗口的文档显示区的宽度。</p>\n<p>但对于IE8及以下版本需要使用clientWidth和clientHeight替代，在标准模式下通过document.documentElement获取，在怪异模式下通过document.body获取。所以，获取视图尺寸可以这么写：</p>\n<pre><code class="language-javascript">function getViewportSize () {\n  if (window.innerWidth != null) {\n    return {\n      w: window.innerWidth,\n      h: window.innerHeight\n    };\n  }\n\n  // 标准模式下的IE\n  var d = document;\n  if (document.compatMode === &#39;CSS1Compat&#39;) {\n    return {\n      w: d.documentElement.clientWidth,\n      h: d.documentElement.clientHeight\n    };\n  }\n\n  // 怪异模式下的浏览器\n  return {\n    x: d.body.clientWidth,\n    y: d.body.clientHeight\n  };\n}</code></pre>\n<h1 id="元素坐标">元素坐标</h1>\n<p>所有HTML元素都拥有offsetLeft和offsetTop属性来返回元素的X和Y坐标。一般来说，这两个属性返回的就是这些元素在文档中的位置，但对于已定位元素的后代元素或者其他一些元素（如表格单元）来说，这两个属性返回的是该元素相对于祖先元素的位置而非相对于文档的位置。查看一个元素的位置是否相对于父元素可以使用offsetParent属性，如果offsetParent为null，offsetLeft和offsetTop属性都是相对于文档的。</p>\n<p>使用offsetLeft和offsetTop来计算元素相对于文档的位置可以这么写：</p>\n<pre><code class="language-javascript">function getElementPosition (e) {\n  var x = 0, y = 0;\n  while (e != null) {\n    x += e.offsetLeft;\n    y += e.offsetTop;\n    e = e.offsetParent;\n  }\n  return {\n    x: x,\n    y: y\n  }\n}</code></pre>\n<p>通过循环offsetParent来累加偏移量，就可以计算出元素相对于文档的真实坐标。</p>\n<p>但如果元素可滚动且有溢出内容时，getElementPosition方法就失效了，这时可以使用W3C标准的element.getBoundingClientRect()，它返回一个有left、right、top、bottom属性的对象，left和top属性表示元素的左上角的X和Y坐标，right和bottom属性表示元素的右下角的X和Y坐标，但getBoundingClientRect()比较消耗性能，慎用。</p>\n<p>其实getBoundingClientRect()的返回值在很多浏览器中还有width和height属性，它们是元素的尺寸（包含边框和内边距），但IE8未实现，所以，为了兼容IE8，可以这么写：</p>\n<pre><code class="language-javascript">var box = e.getBoundingClientRect();\nvar w = box.width || (box.right - box.left);\nvar h = box.height || (box.bottom - box.top);</code></pre>\n<h1 id="元素尺寸">元素尺寸</h1>\n<p>使用元素的offsetWidth和offsetHeight属性可以获取元素的尺寸，它们包含了元素的内容、边框和内边距，不包含外边距。</p>\n<p>若只需要元素的内容和内边距，那么可以使用clientWidth和clientHeight这两个属性来获取元素尺寸，需要注意的是，如果元素带有滚动条，那么滚动条的尺寸不包含在里面；对于内联元素，这两个属性始终返回0。（以“client”开头的还有两个属性：clientLeft和clientTop，这两个属性并没有多大用处，它们通常返回左边和上边的边框宽度，如果元素的左侧或顶部有滚动条，那么这两个属性的值会包含滚动条的宽度。对于内联元素，这两个属性始终返回0）</p>\n<p>当需要获取元素除边框和外边框外的全部尺寸（包含任何溢出的内容）时就需要用到scrollWidth和scrollHeight这两个属性了，当元素内容没有溢出时，这两个属性的返回值与clientWidth和clientHeight相同。</p>\n'}},e7870ac2:{name:"性能监控常用指标",stat:{size:1934,mtime:"2021-01-24T09:26:57.093Z",birthtime:"2021-01-30T10:34:48.248Z"},content:{meta:{title:"性能监控常用指标",time:"2020-11-21",tags:["JavaScript"]},html:'<h2 id="首次绘制事件（fp）">首次绘制事件（FP）</h2>\n<p>对于应用页面，首次出现在视觉上不同于跳转之前内容的时间点，或者说是页面发生第一次绘制的时间。</p>\n<h2 id="首次有内容绘制事件（fcp）">首次有内容绘制事件（FCP）</h2>\n<p>指浏览器完成渲染DOM中第一部分内容（可能是文本、图像或其他任何元素）的时间点，此时用户应该在视觉上有直观的感受。</p>\n<h2 id="首次有意义绘制时间（fmp）">首次有意义绘制时间（FMP）</h2>\n<p>指页面关键元素的渲染时间。这个概念没有标准化定义，因为关键元素可以由开发者自行定义。</p>\n<h2 id="首屏时间">首屏时间</h2>\n<p>对于所有网站应用，这是一个非常重要的指标。它指用户进入页面之后，应用渲染完成整个屏幕（未滚动之前）内容的时间。</p>\n<h2 id="用户可交互时间（tti）">用户可交互时间（TTI）</h2>\n<p>用户可以与应用进行交互的时间。一般来讲，我们认为DOMReady的时间，因为我们通常会在这个时候进行绑定事件操作。如果页面中涉及交互的脚本没有下载完成，那么当然没有达到用户可交互时间。</p>\n<p>DOMReady时间不包括图片之类的资源都加载完毕的时间，如果是需要在所有资源都加载完成可以用onload事件。而DOMReady时间可以通过document.readyState属性来判断，当它变成complete时就表明时机已到，但要注意它不是一个事件，需要我们自己做轮询；通常还是在document上监听DOMContentLoaded事件，对于没有DOMContentLoaded事件的IE8可以用readystatechange事件；而对于更早版本的IE则可以通过每隔一段时间执行一次<code>document.documentElement.doScroll(&quot;left&quot;)</code>来检测这一状态，因为这条代码在DOM加载完毕之前执行时会抛出错误。</p>\n<h2 id="总下载时间">总下载时间</h2>\n<p>页面所有资源加载完成所需要的时间，一般可以使用window.onload统计。</p>\n'}},d15d8b35:{name:"我用Hexo搭建博客时遇到的问题：目录生成",stat:{size:2049,mtime:"2020-12-13T13:14:42.464Z",birthtime:"2020-12-13T10:25:56.922Z"},content:{meta:{title:"我用Hexo搭建博客时遇到的问题：目录生成",time:"2018-01-23",tags:["JavaScript","Hexo"]},html:'<p>hexo自带了生成目录的辅助函数<a href="https://hexo.io/zh-cn/docs/helpers.html#toc">toc</a></p>\n<p>我们可以在layout/_partial/中创建文件toc.ejs</p>\n<pre><code class="language-ejs">&lt;div class=&quot;toc-article&quot;&gt;\n    &lt;h2 class=&quot;toc-article-title&quot;&gt;目录&lt;/h2&gt;\n    &lt;%- toc(page.content) %&gt;\n&lt;/div&gt;</code></pre>\n<p>在文章详情页post.ejs中的适当位置引入toc.ejs</p>\n<pre><code class="language-ejs">&lt;%- partial(&#39;_partial/toc&#39;) %&gt;</code></pre>\n<p>使用</p>\n<pre><code class="language-bash">$ hexo clean\n$ hexo g\n$ hexo s --debug</code></pre>\n<p>三个命令刷新后可以发现，目录列表都正确生成出来了，然而这些a标签的href属性值都为#undefined</p>\n<p><img src="https://s3.ax1x.com/2020/12/13/reOmOs.png" alt="img"></p>\n<p>各层标题的id都已经生成了，怎么a标签的href属性就没有获取到其id值呢？\n一开始我想到是不是中文才会出现这样的问题？所以我新建了一篇文章，使用英文的标题名称，这样id就是英文的了，结果是id确实变为了英文，可目录中a标签的href属性值依然是#undefined。之后又经过几番周折，终于在<a href="https://github.com/YenYuHsuan/hexo-theme-beantech/issues/11/#issuecomment-351266490">这里</a>找到了解决办法\n按照解决方案提供者的说法，新版本的hexo-toc会把标题诸如## title编译成</p>\n<pre><code class="language-html">&lt;h2&gt;&lt;span id=&quot;title&quot;&gt;title&lt;/span&gt;&lt;/h2&gt;</code></pre>\n<p>而旧版本则会编译成</p>\n<pre><code class="language-html">&lt;h2 id=&quot;title&quot;&gt;title&lt;/h2&gt;</code></pre>\n<p>h2没有定义id属性的值，目录中a标签的href属性值也就变成undefined了\n解决办法就是找到/node_modules/hexo-toc/lib/filter.js，把被注释掉的第28行取消注释，然后把第29~31注释掉\n修改完成后：</p>\n<pre><code class="language-javascript">$title.attr(&#39;id&#39;, id);\n// $title.children(&#39;a&#39;).remove();\n// $title.html( &#39;&lt;span id=&quot;&#39; + id + &#39;&quot;&gt;&#39; + $title.html() + &#39;&lt;/span&gt;&#39; );\n// $title.removeAttr(&#39;id&#39;);</code></pre>\n<p>这样就就可以恢复到旧版本，正确获取到目录中a标签href属性值了\n<img src="https://s3.ax1x.com/2020/12/13/reOMT0.png" alt="img"></p>\n'}},"8f4e9f14":{name:"数组重排序方法：reverse()和sort()",stat:{size:2819,mtime:"2020-12-13T12:34:35.089Z",birthtime:"2020-12-13T10:25:56.915Z"},content:{meta:{title:"数组重排序方法：reverse()和sort()",time:"2018-02-04",tags:["JavaScript"]},html:'<p>: |\n|  参数1在参数2前  |   -    |\n| 参数1与参数2相等 |   0    |\n|  参数2在参数1前  |   +    |</p>\n<p>比较函数示例：</p>\n<pre><code class="language-javascript">var arr = [11, 2, 13];\n\nfunction compare(value1, value2) {\n    if (value1 &lt; value2) {\n        return -1;\n    } else if (value1 &gt; value2) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\narr.sort(compare);\nconsole.log(arr.toString());  //2,11,13</code></pre>\n<p>如上面这个例子，把compare()当作比较函数传入sort()方法进行排序后，数组元素得到了正常的升序排序结果</p>\n<p>还可以把compare()中的大于小于号调换一下，就成了降序排序：</p>\n<pre><code class="language-javascript">var arr = [11, 2, 13];\n\nfunction compare(value1, value2) {\n    if (value1 &gt; value2) {\n        return -1;\n    } else if (value1 &lt; value2) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\narr.sort(compare);\nconsole.log(arr.toString());  //13,11,2</code></pre>\n<p>对于纯数值型的数组来说，比较函数的定义还可以更简单：</p>\n<pre><code class="language-javascript">var arr = [11, 2, 13];\n\n// 升序\nfunction ascending (value1, value2) {\n    return value1 - value2;\n}\n\n// 降序\nfunction descending (value1, value2) {\n    return value2 - value1;\n}\n\narr.sort(ascending);\nconsole.log(arr.toString());  //2,11,13\n\narr.sort(descending);\nconsole.log(arr.toString());  //13,11,2</code></pre>\n'}},"964e310b":{name:"类型判断",stat:{size:6931,mtime:"2021-02-21T05:35:42.776Z",birthtime:"2020-11-07T13:00:28.085Z"},content:{meta:{title:"类型判断",time:"2020-10-08",tags:["JavaScript"]},html:'<h1 id="类型判断">类型判断</h1>\n<h2 id="数据类型">数据类型</h2>\n<h3 id="基本类型（值类型）">基本类型（值类型）</h3>\n<p>ES5：String、Number、Boolean、null、undefined</p>\n<p>ES6（ES2015）：Symbol</p>\n<p>ES11（ES2020）：BigInt</p>\n<p>共七种</p>\n<p>文章</p>\n<h3 id="引用类型">引用类型</h3>\n<p>Object</p>\n<h2 id="typeof">typeof</h2>\n<p>只对大多数基本类型有效，除了对null、Object都返回字符串object。</p>\n<pre><code class="language-javascript">typeof &quot;abc&quot;  // string</code></pre>\n<h2 id="instanceof">instanceof</h2>\n<p>判断依据是检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链（对象是否是某个构造函数的实例）</p>\n<p>语法：</p>\n<pre><code class="language-javascript">object instanceof constructor</code></pre>\n<p>其中，<code>object</code>为某个实例对象，<code>constructor</code>为某个构造函数</p>\n<p><strong>判断的是<code>constructor.prototype </code>是否存在于参数 <code>object</code> 的原型链上</strong></p>\n<pre><code class="language-javascript">function A () {}\n\nconst a = new A()\n\na instanceof A  // true\n// Object.getPrototypeOf(a) === A.prototype  // true</code></pre>\n<p>需要注意的是当使用instanceof判断非字面量的方式创建的基本类型（null、undefined除外）与Object的关系时，都会返回true。</p>\n<p>另外依据null作为原型而被构造出来的对象也无法用instanceof来成功判断是Object的实例。</p>\n<pre><code class="language-javascript">// MDN上的例子\nvar simpleStr = &quot;This is a simple string&quot;; \nvar myString  = new String();\nvar newStr    = new String(&quot;String created with constructor&quot;);\nvar myDate    = new Date();\nvar myObj     = {};\nvar myNonObj  = Object.create(null);\n\nsimpleStr instanceof String; // 返回 false, 检查原型链会找到 undefined\nmyString  instanceof String; // 返回 true\nnewStr    instanceof String; // 返回 true\nmyString  instanceof Object; // 返回 true\n\nmyObj instanceof Object;    // 返回 true, 尽管原型没有定义\n({})  instanceof Object;    // 返回 true, 同上\nmyNonObj instanceof Object; // 返回 false, 一种创建非 Object 实例的对象的方法\n\nmyString instanceof Date; //返回 false\n\nmyDate instanceof Date;     // 返回 true\nmyDate instanceof Object;   // 返回 true\nmyDate instanceof String;   // 返回 false</code></pre>\n<p>instanceof还可以应用于防止在使用构造函数构造对象时没有使用new关键字，而是直接调用函数的情况：</p>\n<pre><code class="language-javascript">function MyObj (...args) {\n    if (!(this instanceof MyObj)) {\n        return new MyObj(...args)\n    }\n    // something...\n}</code></pre>\n<p>在对<code>instanceof</code>的理解上，<code>Object.prototype.isPrototypeOf()</code>可能会与其发生混淆，<code>instanceof</code>是针对<code>constructor.prototype</code>进行检查的，而在表达式<code>prototypeObj.isPrototypeOf(object)</code>中，是针对<code>object</code>的原型链上进行搜寻有无<code>prototypeObj</code>的存在。</p>\n<pre><code class="language-javascript">// 检查bar对象是否继承自Foo.prototype\nFoo.prototype.isPrototypeOf(bar)</code></pre>\n<pre><code class="language-javascript">// MDN上的例子\nfunction Foo() {}\nfunction Bar() {}\nfunction Baz() {}\n\nBar.prototype = Object.create(Foo.prototype);\nBaz.prototype = Object.create(Bar.prototype);\n\nvar baz = new Baz();\n\nconsole.log(Baz.prototype.isPrototypeOf(baz)); // true\nconsole.log(Bar.prototype.isPrototypeOf(baz)); // true\nconsole.log(Foo.prototype.isPrototypeOf(baz)); // true\nconsole.log(Object.prototype.isPrototypeOf(baz)); // true\n\n// 此时\nbaz.__proto__ === bar.__proto__  // false\nbaz.__proto__.__proto__ === bar.__proto__  // true\nbaz.__proto__.__proto__  // Foo {}\nbaz.__proto__  // Foo {}  但与baz.__proto__.__proto__不同，该Foo对象的__proto__才是baz.__proto__.__proto__\nbaz.__proto__ === Baz.prototype  // true</code></pre>\n<h2 id="constructor">constructor</h2>\n<p>除了使用诸如<code>Object.create(null)</code>等方法创建出来的对象以外，其他所有正常的对象都能继承到<code>constructor</code>属性，我们可以通过这个<code>constructor</code>属性来判断对象的类型。</p>\n<pre><code class="language-javascript">const arr = []\narr.constructor === Array // true\n\nconst arr2 = new Array()\narr2.constructor === Array // true</code></pre>\n<p>但要注意的是除了使用字面量创建出来的基本类型对象以外（创建他们的是只读的原生构造函数（native constructors）），对象的<code>constructor</code>是可以被改变的，所以使用<code>constructor</code>来判断类型并不能成为一个靠谱的方法。</p>\n<pre><code class="language-javascript">let arr = new Array()\nlet trueValue = true\nfunction Foo () {}\n\narr.constructor = Foo\ntrueValue.constructor = Foo\narr.constructor  // ƒ Foo () {}\nconstructor.constructor  // ƒ Boolean() { [native code] }</code></pre>\n<h2 id="objectprototypetostring">Object.prototype.toString</h2>\n<p>通过<code>Function.prototype.call()</code>借用<code>Object.prototype.toString</code>方法，将要判断的对象作为第一个参数传入就能用于对象的类型检测。</p>\n<pre><code class="language-javascript">Object.prototype.toString.call()              // &quot;[object Undefined]&quot;\nObject.prototype.toString.call(undefined)     // &quot;[object Undefined]&quot;\nObject.prototype.toString.call(null)          // &quot;[object Null]&quot;\nObject.prototype.toString.call(new Date())    // &quot;[object Date]&quot;\nObject.prototype.toString.call(new Array())   // &quot;[object Array]&quot;\nObject.prototype.toString.call([])            // &quot;[object Array]&quot;\nObject.prototype.toString.call(new String())  // &quot;[object String]&quot;\nObject.prototype.toString.call(&#39;str&#39;)         // &quot;[object String]&quot;\nObject.prototype.toString.call(new Number())  // &quot;[object Number]&quot;\nObject.prototype.toString.call(123)           // &quot;[object Number]&quot;\nObject.prototype.toString.call(new Object)    // &quot;[object Object]&quot;\nObject.prototype.toString.call({})            // &quot;[object Object]&quot;\nObject.prototype.toString.call(() =&gt; {})      // &quot;[object Function]&quot;\nObject.prototype.toString.call(BigInt(1))     // &quot;[object BigInt]&quot;\nObject.prototype.toString.call(Symbol())      // &quot;[object Symbol]&quot;\nObject.prototype.toString.call(Math)          // &quot;[object Math]&quot;\nObject.prototype.toString.call(new Error())   // &quot;[object Error]&quot;\nObject.prototype.toString.call(new RegExp())  // &quot;[object RegExp]&quot;\nObject.prototype.toString.call(JSON)          // &quot;[object JSON]&quot;\nObject.prototype.toString.call(new Set())     // &quot;[object Set]&quot;\nObject.prototype.toString.call(new Map())     // &quot;[object Map]&quot;\nObject.prototype.toString.call(new WeakSet()) // &quot;[object WeakSet]&quot;\nObject.prototype.toString.call(new WeakMap()) // &quot;[object WeakMap]&quot;\n(function () { \n  return Object.prototype.toString.call(arguments) \n})()                                          // &quot;[object Arguments]&quot;</code></pre>\n<p>但对于使用自定义构造函数构造的对象，<code>Object.prototype.toString</code>方法并不能准确判断出是由哪个构造函数构造的，所以<code>Object.prototype.toString</code>只能用于判断内置类型</p>\n<pre><code class="language-javascript">function MyObj () {}\nconst obj = new MyObj()\nObject.prototype.toString.call(obj)  // &quot;[object Object]&quot;</code></pre>\n<blockquote>\n<p>官方文档：<a href="https://tc39.es/ecma262/#sec-object.prototype.tostring"><code>Object.prototype.toString()</code>做了什么事情？</a></p>\n</blockquote>\n'}},"62e840bf":{name:"给mand-mobile配置pxtorem",stat:{size:4127,mtime:"2020-12-13T13:14:11.769Z",birthtime:"2020-12-13T10:25:56.865Z"},content:{meta:{title:"给mand-mobile配置pxtorem",time:"2019-05-31",tags:["JavaScript","Vue.js","Webpack"]},html:'<p>由滴滴开发的Vue移动端UI组件库<a href="https://didi.github.io/mand-mobile/">mand-mobile</a>的产出包<code>lib</code>目录中的组件样式默认以<code>px</code>为单位，直接使用可能会显得比例很大，有必要的话就可以使用<code>postcss-pxtorem</code>来将mand的组件的px单位按比例转换为rem。</p>\n<p>在文档中也有配置方法：<a href="https://didi.github.io/mand-mobile/#/zh-CN/docs/started?anchor=%E4%BD%BF%E7%94%A8%E5%89%8D%E5%87%86%E5%A4%87">https://didi.github.io/mand-mobile/#/zh-CN/docs/started?anchor=%E4%BD%BF%E7%94%A8%E5%89%8D%E5%87%86%E5%A4%87。</a></p>\n<p>本文记录的是在vue.config.js中配置pxtorem的另外几种方法。</p>\n<h2 id="方法一：">方法一：</h2>\n<p>Vue CLI 内部使用了 PostCSS，我们可以通过<code>css.loaderOptions.postcss</code> 配置 <a href="https://github.com/postcss/postcss-loader">postcss-loader</a>：</p>\n<pre><code class="language-javascript">// vue.config.js\nconst pxtorem = require(&#39;postcss-pxtorem&#39;);\n\nmodule.exports = {\n  css: {\n    loaderOptions: {\n      postcss: {\n        plugins: [\n          pxtorem({\n            rootValue: 30,\n            minPixelValue: 2,\n            propList: [&#39;*&#39;],\n            selectorBlackList: []\n          }),\n            ]\n      }\n    }\n  },\n};</code></pre>\n<p>这样是直接作用于全局的，即无论是不是mand的组件，只要带px单位的css属性值都会被转换成rem单位，当然你也可以配置selectorBlackList数组来排除某些选择器，也可以配置propList数组来选择需要转换单位的属性，详细可以看postcss-loader的文档：<a href="https://github.com/cuth/postcss-pxtorem%E3%80%82">https://github.com/cuth/postcss-pxtorem。</a></p>\n<p>这种方法还有一个问题：在用了某些同样需要配置postcss的库后可能就无法直接使用这种方法，下面以配置ckeditor主题为例，加入pxtorem的配置。</p>\n<h2 id="方法二">方法二</h2>\n<pre><code class="language-javascript">// vue.config.js\nconst { styles } = require(&#39;@ckeditor/ckeditor5-dev-utils&#39;);\n\nconst postCssConfig = styles.getPostCssConfig({\n  themeImporter: {\n    themePath: require.resolve(&#39;@ckeditor/ckeditor5-theme-lark&#39;)\n  },\n  minify: true,\n});\n\nmodule.exports = {\n  css: {\n    loaderOptions: {\n      postcss: postCssConfig\n    }\n  },\n};</code></pre>\n<p>在对ckeditor5的主题进行配置后我们无法直接像方法一那样加入pxtorem的配置，但其实styles.getPostCssConfig()就返回了</p>\n<pre><code class="language-javascript">{\n  plugins: []\n}</code></pre>\n<p>这种结构。</p>\n<p>所以我们可以通过<code>postCssConfig.plugins.push()</code>来添加pxtorem的配置：</p>\n<pre><code class="language-javascript">// vue.config.js\nconst pxtorem = require(&#39;postcss-pxtorem&#39;);\nconst { styles } = require(&#39;@ckeditor/ckeditor5-dev-utils&#39;);\n\nconst postCssConfig = styles.getPostCssConfig({\n  themeImporter: {\n    themePath: require.resolve(&#39;@ckeditor/ckeditor5-theme-lark&#39;)\n  },\n  minify: true,\n});\n\npostCssConfig.plugins.push(pxtorem({\n  rootValue: 30,\n  minPixelValue: 2,\n  propList: [&#39;*&#39;],\n  selectorBlackList: []\n}));\n\nmodule.exports = {\n  css: {\n    loaderOptions: {\n      postcss: postCssConfig\n    }\n  },\n};</code></pre>\n<p>但这种方法还是无法完全实现pxtorem只作用于mand组件的问题。</p>\n<h2 id="方法三（推荐）">方法三（推荐）</h2>\n<p>利用<code>vue.config.js</code>中的<a href="https://cli.vuejs.org/zh/config/#chainwebpack">chainWebpack</a>属性我们可以对内部的 webpack 配置进行更细粒度的修改：</p>\n<pre><code class="language-javascript">// vue.config.js\nconst pxtorem = require(&#39;postcss-pxtorem&#39;);\n\nmodule.exports = {\n  chainWebpack: config =&gt; {\n    config.module\n      .rule(&#39;md-postcss&#39;)  // 新增规则，规则名自定义\n      .test(/mand-mobile.*\\.css$/)  // 用正则表达式匹配mand-mobile的组件目录下的所有css文件\n      .use(&#39;css-loader&#39;)  // css加载器\n      .loader(&#39;postcss-loader&#39;)  // css处理器\n      .options({  // 这里的内容跟方法一中css.loaderOptions一样\n        plugins: [\n          pxtorem({\n            rootValue: 30,\n            minPixelValue: 2,\n            propList: [&#39;*&#39;],\n            selectorBlackList: []\n          })\n        ]\n      });\n  }\n};</code></pre>\n<p>这样既不跟其他库发生冲突又能实现pxtorem的处理只作用于mand的组件了。</p>\n'}},"18d3cfbc":{name:"编写一个简单的Node.js C++插件",stat:{size:2800,mtime:"2020-12-13T13:13:53.019Z",birthtime:"2020-12-13T10:25:56.819Z"},content:{meta:{title:"编写一个简单的Node.jsC++插件",time:"2018-06-15",tags:["JavaScript","Node.js"]},html:'<p>以上内容参考自Node.js v10.3.0 文档：<a href="http://nodejs.cn/api/addons.html">http://nodejs.cn/api/addons.html</a></p>\n'}},"546bb754":{name:"隐式类型转换",stat:{size:3169,mtime:"2021-01-30T09:51:34.055Z",birthtime:"2021-01-30T10:34:48.254Z"},content:{meta:{title:"隐式类型转换",time:"2020-09-21",tags:["JavaScript"]},html:'<p>JavaScript是弱类型语言，所以会存在两个不同类型的变量之间进行数学运算的情况</p>\n<h2 id="减、乘、除">减、乘、除</h2>\n<p>对于非Number类型的都会先转换为Number类型，再进行运算（对于对象，会优先调用valueOf方法，没有定义valueOf方法时再调用toString方法）</p>\n<pre><code class="language-javascript">1 - true // 0， 首先把 true 转换为数字 1， 然后执行 1 - 1\n&#39;1&#39; - 2  // -1\n1 - null // 1,  首先把 null 转换为数字 0， 然后执行 1 - 0\n1 * undefined //  NaN, undefined 转换为数字是 NaN\n2 * [&#39;5&#39;] //  10， [&#39;5&#39;]首先会变成 &#39;5&#39;, 然后再变成数字 5</code></pre>\n<h2 id="加法">加法</h2>\n<p>加法比较特殊，因为并不一定是数学运算，还涉及到了字符串拼接。加法的规则可以分为以下两部分：</p>\n<h3 id="1、运算符两边都是number类型">1、+运算符两边都是Number类型</h3>\n<ul>\n<li>如果+运算符两边存在NaN，则结果为NaN</li>\n<li>如果是Infinity + Infinity，则结果是Infinity</li>\n<li>如果是-Infinity + (-Infinity)，则结果是-Infinity</li>\n<li>如果是Infinity + (-Infinity)，则结果是NaN</li>\n</ul>\n<h3 id="2、运算符两边至少有一个是字符串">2、+运算符两边至少有一个是字符串</h3>\n<ul>\n<li>如果+运算符两边都是字符串，则进行字符串拼接</li>\n<li>如果+运算符两边只有一个是字符串，则将另外的值转换为字符串，在进行字符串的拼接</li>\n<li>如果+运算符两边有一个是对象，则调用valueOf或toString方法取得值，将其转换为基本类型再进行字符串拼接</li>\n</ul>\n<h2 id="在逻辑语句中的类型转换">在逻辑语句中的类型转换</h2>\n<p>在诸如<code>if</code>、<code>for</code>、<code>while</code>、三元运算等语句中，也会涉及到了隐式转换，期望值为Boolean。</p>\n<p>其中只有 <code>null</code>、<code>undefined</code>、<code>&#39;&#39;</code>、<code>NaN</code>、<code>0</code> 这几个是 false，其他的情况都会转换成 true，比如 <code>{}</code> 、<code>[]</code>。</p>\n<h2 id="在双等（）中的类型转换">在双等（==）中的类型转换</h2>\n<p>1、NaN与其他任何类型都不相等（包括其自己）</p>\n<pre><code class="language-javascript">NaN == NaN  // false</code></pre>\n<p>2、String和Number比较时，String会转换为Number</p>\n<pre><code class="language-javascript">123 == &#39;123&#39; // true，&#39;123&#39;转换为123\n&#39;&#39; == 0 // true, &#39;&#39; 会转换为0</code></pre>\n<p>3、null == undefined比较结果是<code>true</code>，除此之外，<code>null</code>、<code>undefined</code>和其他任何结果的比较值都为<code>false</code></p>\n<pre><code class="language-javascript">null == undefined // true\nnull == &#39;&#39; // false\nnull == 0 // false\nnull == false // false\nundefined == &#39;&#39; // false\nundefined == 0 // false\nundefined == false // false</code></pre>\n<p>4、当基本类型和引用类型相比较时，引用类型会调用valueOf或toString方法然后再比较</p>\n<pre><code class="language-javascript">&#39;[object Object]&#39; == {} \n// true, 对象和字符串比较，对象通过 toString 得到一个基本类型值\n&#39;1,2,3&#39; == [1, 2, 3] \n// true, 同上  [1, 2, 3]通过 toString 得到一个基本类型值</code></pre>\n<p>5、Boolean 和其他任何类型比较时，Boolean会被转换为 Number 类型</p>\n<pre><code class="language-javascript">true == 1  // true \ntrue == &#39;2&#39;  // false, 先把 true 变成 1，而不是把 &#39;2&#39; 变成 true\ntrue == [&#39;1&#39;]  // true, 先把 true 变成 1， [&#39;1&#39;]拆箱成 &#39;1&#39;\nundefined == false // false ，首先 false 变成 0\nnull == false // false，同上</code></pre>\n'}}}));