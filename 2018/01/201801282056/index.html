<!DOCTYPE html>
<html lang="zh-cn">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="author" content="RGM">
  <meta name="keywords" content="前端,front end,javascript,js,css,html,node">
  <meta name="description" content="RGM的个人博客，分享自己的学习与理解">
  <title>RGM's BLOG</title>
  <link rel="stylesheet" href="/css/main.min.css">
</head>
<body>
  <div class='main full-width'>
    <header>
  <a href="/" class="brand">RGM's BLOG</a>

  <span class="about-me">About me
</span></header>

<nav class="top-nav">
  <ul class="nav">
  

  
    <li>
      <a href="/" class="current">我的随笔</a>
    </li>
  
  </ul>
</nav>


    <article class="article-main">
  <div class="article-title">
    <h1 class="title">我在学Python（三）</h1>
  </div>
  <div class="article-meta">
  
    <span class="article-time">Sunday, 28 Jan 2018</span>
    <div class="tags">
      Tags: 
      
        <a href="/tags/Python/">
          <span style="background-color: #347ab5; color: #fff">
            Python
          </span>
        </a>
      
    </div>
  </div>
  <div class="article-content">
    <h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><pre><code class="python">class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def print_msg(self):
        print(&#39;name: %s, age: %s&#39; % (self.name, self.age))


p1 = Person(&#39;xiaoming&#39;, 20)
p1.print_msg()    #name: xiaoming, age: 20
</code></pre>
<p>__init__函数是这个类的构造函数，self是必须的且永远是作为第一个参数，类实例化成对象的时候回自动传入这个类，所以我们只需要给它传入我们自己的参数；print_msg()是这个类的类方法，可以不止有一个，同样的self也不需要我们自己传入；最后两行是实例化，调用类方法</p>
<p>如果想让外部无权限访问类中的变量，，可以把变量定义为私有变量（默认情况下是公有变量），只需要在变量前面加上两个下划线__</p>
<pre><code class="python">class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.__age = age

    def print_msg(self):
        print(&#39;name: %s, age: %s&#39; % (self.name, self.__age))
</code></pre>
<p>这时，外部就不能访问到__age了</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>子类继承父类后会获得父类的方法和变量，在子类中还可以定义父类中没有的方法</p>
<pre><code class="python">class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.__age = age

    def print_msg(self):
        print(&#39;name: %s, age: %s&#39; % (self.name, self.__age))


class Student(Person):
    def set_score(self, score):
        self.__score = score

p1 = Person(&#39;xiaoming&#39;, 20)
p1.print_msg()    #name: xiaoming, age: 20
s1 = Student(&#39;xiaohong&#39;, 20)
s1.print_msg()    #name: xiaohong, age: 20
</code></pre>
<p>还可以在子类中重写父类的方法，这就是多态，当使用子类的实例去调用这个重写的方法时就不会再调用父类的那个被重写的方法了</p>
<pre><code class="python">class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def print_msg(self):
        print(&#39;name: %s, age: %s&#39; % (self.name, self.age))


class Student(Person):
    def set_score(self, score):
        self.__score = score

    def print_msg(self):
        print(&#39;name: %s, age: %s, score: %s&#39; % (self.name, self.age, self.__score))

p1 = Person(&#39;xiaoming&#39;, 20)
p1.print_msg()    #name: xiaoming, age: 20
s1 = Student(&#39;xiaohong&#39;, 20)
s1.set_score(90)
s1.print_msg()    #name: xiaohong, age: 20, score: 90
</code></pre>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><pre><code class="python">class A(object):
    def __init__(self, nameA):
        self.nameA = nameA


class B(object):
    def __init__(self, nameB):
        self.nameB = nameB


class C(A, B):
    pass
</code></pre>
<p>如果现在假设有A、B、C、D四个类，B和C为A的子类，D为A、B、C的子类，则称B、C类为混入类，这时候D的定义就该使用MixIn这种设计，把B写成BMixIn，C写成CMinIn，若有其他A的子类也这样写</p>
<pre><code class="python">class A(object):
    def __init__(self, nameA):
        self.nameA = nameA


class BMixIn(A):
    pass


class CMixIn(A):
    pass


class D(A, BMixIn, CMixIn):
    pass
</code></pre>
<h2 id="实例变量和类变量"><a href="#实例变量和类变量" class="headerlink" title="实例变量和类变量"></a>实例变量和类变量</h2><p>以上例子定义的变量都是实例变量，那类变量是怎样定义的？把变量直接写到函数以外就成类变量了，但是需要注意，实例变量 不要跟类变量名重复，否则实例变量会屏蔽类变量</p>
<pre><code class="python">class Person(object):
    name = &#39;xiaoming&#39;

    def __init__(self, age):
        self.age = age

    def print_msg(self):
        print(&#39;name: %s, age: %s&#39; % (self.name, self.age))


p1 = Person(20)
p1.print_msg()    #name: xiaoming, age: 20
</code></pre>
<h2 id="获取对象的类型"><a href="#获取对象的类型" class="headerlink" title="获取对象的类型"></a>获取对象的类型</h2><p>type()可以获取一个对象的类型</p>
<pre><code class="python">class Person(object):
    name = &#39;xiaoming&#39;

    def __init__(self, age):
        self.age = age

    def print_msg(self):
        print(&#39;name: %s, age: %s&#39; % (self.name, self.age))


p1 = Person(20)
print(type(p1))    #&lt;class &#39;__main__.Person&#39;&gt;
</code></pre>
<p>isinstance()不仅可以判断一个对象是否属于某个类，可以判断一个对象它所属的类是否在这个类的继承链上</p>
<pre><code class="python">class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def print_msg(self):
        print(&#39;name: %s, age: %s&#39; % (self.name, self.age))


class Student(Person):
    def set_score(self, score):
        self.__score = score

    def print_msg(self):
        print(&#39;name: %s, age: %s, score: %s&#39; % (self.name, self.age, self.__score))

p1 = Person(&#39;xiaoming&#39;, 20)
s1 = Student(&#39;xiaohong&#39;, 20)

print(isinstance(p1, Person))    #True
print(isinstance(p1, Student))   #False
print(isinstance(s1, Person))    #True
print(isinstance(s1, Student))   #True
</code></pre>
<h2 id="获取对象的属性和方法"><a href="#获取对象的属性和方法" class="headerlink" title="获取对象的属性和方法"></a>获取对象的属性和方法</h2><p>使用dir()就可以获取对象的所有属性和方法，返回一个list</p>
<pre><code class="python">class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def print_msg(self):
        print(&#39;name: %s, age: %s&#39; % (self.name, self.age))



p1 = Person(&#39;xiaoming&#39;, 20)
print(dir(p1))    #[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;age&#39;, &#39;name&#39;, &#39;print_msg&#39;]
</code></pre>
<p>Python也提供了getattr()、setattr()和hasattr()</p>
<pre><code class="python">class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def print_msg(self):
        print(&#39;name: %s, age: %s&#39; % (self.name, self.age))



p1 = Person(&#39;xiaoming&#39;, 20)
print(getattr(p1, &#39;name&#39;))  #xiaoming
print(hasattr(p1, &#39;age&#39;))   #True
setattr(p1, &#39;age&#39;, 21)
print(p1.age)               #21
</code></pre>
<h2 id="绑定属性和方法"><a href="#绑定属性和方法" class="headerlink" title="绑定属性和方法"></a>绑定属性和方法</h2><p>给对象绑定属性和方法：</p>
<pre><code class="python">from types import MethodType


class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def print_msg(self):
        print(&#39;name: %s, age: %s&#39; % (self.name, self.age))


p1 = Person(&#39;xiaoming&#39;, 20)
p1.sex = &#39;male&#39;


def print_name(self):
    print(self.name)


p1.print_name = MethodType(print_name, p1)
</code></pre>
<p>新绑定的属性和方法只存在与这个对象，其他同一个类的对象都没有<br>为了防止过分绑定属性和方法，可以使用__slots__来限制可以绑定的属性和方法</p>
<pre><code class="python">from types import MethodType


class Person(object):
    __slots__ = (&#39;name&#39;, &#39;age&#39;, &#39;print_name&#39;)

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def print_msg(self):
        print(&#39;name: %s, age: %s&#39; % (self.name, self.age))


p1 = Person(&#39;xiaoming&#39;, 20)


def print_name(self):
    print(self.name)


p1.print_name = MethodType(print_name, p1)
</code></pre>
<p>在上面这个例子中__slots__限制了这个类只能有name（在构造函数已定义）、age（在构造函数已定义）、print_name，而sex就不能被绑定上去了，需要注意的是，这个类的子类是不能被这个__slots__特殊变量所限制的</p>
<pre><code class="python">from types import MethodType


class Person(object):
    __slots__ = (&#39;name&#39;, &#39;age&#39;, &#39;print_name&#39;)

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def print_msg(self):
        print(&#39;name: %s, age: %s&#39; % (self.name, self.age))


p1 = Person(&#39;xiaoming&#39;, 20)


def print_name(self):
    print(self.name)


p1.print_name = MethodType(print_name, p1)


class Student(Person):
    pass


s1 = Student(&#39;xiaodong&#39;, 20)
print(s1.name)    #xiaodong
s1.sex = &#39;male&#39;
print(s1.sex)     #male
</code></pre>
<p>除非在子类中也添加了__slots__这个特殊变量，那么子类的__solts__实际上是子类中加的在加上父类的__solts__</p>
<pre><code class="python">from types import MethodType


class Person(object):
    __slots__ = (&#39;name&#39;, &#39;age&#39;, &#39;print_name&#39;)

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def print_msg(self):
        print(&#39;name: %s, age: %s&#39; % (self.name, self.age))


p1 = Person(&#39;xiaoming&#39;, 20)


def print_name(self):
    print(self.name)


p1.print_name = MethodType(print_name, p1)


class Student(Person):
    __slots__ = &#39;addr&#39;


s1 = Student(&#39;xiaohong&#39;, 20)
print(s1.name)
s1.sex = &#39;male&#39;    #这里会抛出异常
</code></pre>
<h2 id="设置对象的属性值"><a href="#设置对象的属性值" class="headerlink" title="设置对象的属性值"></a>设置对象的属性值</h2><p>如果直接给对象中的属性设置值，那么会不安全，可能会因为输入类型不同而抛出异常，这时新定义一个函数用来给属性设置值就可以提供检查各种异常的功能，不过有更简便的方法，那就是使用@property装饰器</p>
<pre><code class="python">class Person(object):
    def __init__(self, name):
        self.name = name

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, age):
        self._age = age


p1 = Person(&#39;xiaoming&#39;)
p1.age = 20
print(p1.age)
</code></pre>
<p>@property装饰器把一个方法变成属性去调用了，@property下的方法就是一个getter方法，用户对这个属性赋的值将交给@property.setter下的方法，比如上面这个例子中就是@age.setter，因为要被改变的就是age属性，在@property.setter下的这个方法中我们可以对传入的值进行检查、处理各种异常</p>
<p>@property还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</p>
<pre><code class="python">class Person(object):
    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, age):
        self._age = age

    @property
    def name(self):
        return &#39;xiaoming&#39;

p1 = Person()
p1.age = 20
print(p1.age)    #20
print(p1.name)   #xiaoming
</code></pre>
<p>@property还有deleter方法，用法与setter方法一样</p>
<h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><h3 id="__getattr__"><a href="#getattr" class="headerlink" title="__getattr__"></a>__getattr__</h3><p>在我们调用类中不存在的属性或方法时会抛出异常，而__getattr__可以避开这个错误</p>
<pre><code class="python">class Person(object):
    def __init__(self, name):
        self.name = name

    def __getattr__(self, attr):
        if attr == &#39;age&#39;:
            return 20
        if attr == &#39;print_name&#39;:
            return lambda: print(&#39;name: &#39; + self.name)


p1 = Person(&#39;xiaoming&#39;)
print(p1.age)    #20
p1.print_name()  #name: xiaoming
</code></pre>
<p>这样，当调用这个不存在的属性时就不会抛出异常并返回一个设定好的结果</p>
<h3 id="__call__"><a href="#call" class="headerlink" title="__call__"></a>__call__</h3><p>__call__可以使对象本身可以像函数一样调用</p>
<pre><code class="python">class Person(object):
    def __init__(self, name):
        self.name = name

    def __call__(self, *args, **kwargs):
        print(&#39;name: &#39; + self.name)


p1 = Person(&#39;xiaoming&#39;)
p1()    #name: xiaoming
</code></pre>
<p>__call__()也是可以传入参数进行处理的<br>但现在出现了一个问题，我们怎么分辨一个变量是对象还是函数？能够被调用的就是个Callable对象，我们可以用callable()进行判断一个变量是否为可调用对象</p>
<pre><code class="python">class Person(object):
    def __init__(self, name):
        self.name = name

    def __call__(self, *args, **kwargs):
        print(&#39;name: &#39; + self.name)


p1 = Person(&#39;xiaoming&#39;)
print(callable(p1))       #True
print(callable(&#39;123&#39;))    #False
</code></pre>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>Enum类可以创建枚举类：</p>
<pre><code class="python">from enum import Enum

Month = Enum(&#39;Month&#39;, (&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;))

for name, member in Month.__members__.items():
    print(name, member.value)
</code></pre>
<p>value属性是自动赋给成员的整数型常量，从1开始累计，所以在上面这个例子中会打印出每一个月的英文简写及对应的阿拉伯数字</p>
<p>还可以让Enum类作为父类，自定义一个枚举类：</p>
<pre><code class="python">from enum import Enum, unique


@unique
class Weekday(Enum):
    Sun = 0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6


print(Weekday.Mon.value)       #1
print(Weekday[&#39;Mon&#39;].value)    #1
print(Weekday(1).value)        #1

for name, member in Weekday.__members__.items():
    print(name,  member.value)
</code></pre>
<p>在上面这个例子中@unique可以检测有没有重复值</p>

  </div>
</article>
<div class="end-line"></div>
<!-- Highlight.js -->
<link rel="stylesheet" href="/css/atom-one-dark.min.css">
<script src="/js/highlight.pack.min.js"></script>
<script>
  (function(){
    hljs.initHighlightingOnLoad();

    var articleContent = document.getElementsByClassName('article-content')[0];
    setTimeout(function () {
      articleContent.className = "article-content article-content-come";
    }, 100);

    // 新窗口打开图片
    function openImg (event) {
      window.open(event.target.src, '_blank');
    }

    var imgs = document.getElementsByClassName('article-content')[0].getElementsByTagName('img');
    
    Array.prototype.forEach.call(imgs, function (img) {
      img.addEventListener('click', openImg);
    });
  })();
</script>

    
<script>
  (function () {
    // 渐入动画
    var posts = document.getElementsByClassName('post'),
      pageNav = document.getElementsByClassName('page-nav')[0];

    Array.prototype.forEach.call(posts, function (post, index) {
      setTimeout(function () {
        post.className = "post post-come";

        if (index >= posts.length - 1 && pageNav) {
          setTimeout(function () {
            pageNav.className = "page-nav page-nav-come";
          }, 500);
        }
      }, index === 0 ? 0 : index * 200);
    });
  })();
</script>
  </div>
  <div class="me">
  <img alt="avatar" class="avatar">
  <p class="me-p">Live by the sword and die by the sword.</p>
  <div class="links">
    <a href="https://github.com/RGM-89sc" target="_blank" class="link github-link" title="github"></a>
    <a href="mailto:171716669@qq.com" class="link mail-link" title="mail"></a>
  </div>
  <div class="all-tags">
  <span>Tags: </span>
  <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ANSI/">ANSI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">19</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-js/">Vue.js</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内网穿透/">内网穿透</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a><span class="tag-list-count">2</span></li></ul>
  </div>
</div>
  <script src="/js/main.min.js"></script>
  
</body>
</html>